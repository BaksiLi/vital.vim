Describe Data.List.Closure
  Before all
    let V = vital#vital#new()
    let Closure = V.import('Data.Closure')
    let ListCl = V.import('Data.List.Closure')

    function! Plus(x, y) abort
      return a:x + a:y
    endfunction

    function! Pair(x, y) abort
      return [a:x, a:y]
    endfunction
  End

  After all
    delfunction Plus
    delfunction Pair
  End

  Describe .map()
    Before all
      function! Succ(x) abort
        return a:x + 1
      endfunction
    End

    After all
      delfunction Succ
    End

    It maps given the callable to a list without indice
      let succ = Closure.from_funcref(function('Succ'))
      Assert Equals(ListCl.map([1, 2, 3], succ), [2, 3, 4])
    End
  End

  Describe .foldl()
    It folds a list from left with the callable
      let plus = Closure.from_funcname('*Plus')
      let pair = Closure.from_funcname('*Pair')

      Assert Equals(ListCl.foldl(plus, 0, range(1, 10)), 55)
      Assert Equals(ListCl.foldl(pair, 0, [1, 2]), [[0, 1], 2])
    End
  End

  Describe .foldl1()
    It folds a list from left with the callable
      let plus = Closure.from_funcname('*Plus')
      let pair = Closure.from_funcname('*Pair')

      Assert Equals(ListCl.foldl1(plus,  range(0, 10)), 55)
      Assert Equals(ListCl.foldl1(pair,  [0, 1, 2]), [[0, 1], 2])
    End
  End

  Describe .foldr()
    It folds a list from right with the callable
      let plus = Closure.from_funcname('*Plus')
      let pair = Closure.from_funcname('*Pair')

      Assert Equals(ListCl.foldr(plus, 0, range(1, 10)), 55)
      Assert Equals(ListCl.foldr(pair, 3, [1, 2]), [1, [2, 3]])
    End
  End

  Describe .foldr1()
    It folds a list from right with the callable
      let plus = Closure.from_funcname('*Plus')
      let pair = Closure.from_funcname('*Pair')

      Assert Equals(ListCl.foldr1(plus, range(0, 10)), 55)
      Assert Equals(ListCl.foldr1(pair, [0, 1, 2]), [0, [1, 2]])
    End
  End

  Describe .uniq_by()
    It makes a list unique based on given the callable
      let tolower_ = Closure.from_funcref(function('tolower'))
      Assert Equals(
      \ ListCl.uniq_by([
      \       'vim', 'Vim', 'VIM', 'emacs', 'Emacs', 'EMACS', 'gVim', 'GVIM'
      \     ],
      \     tolower_
      \   ),
      \ [
      \   'vim', 'emacs', 'gVim'
      \ ]
      \ )
    End
  End

  Describe .max_by()
    It returns a maximum value in the non empty list through the given the callable
      let len = Closure.from_funcname('*len')
      let abs = Closure.from_funcname('*abs')

      Assert Equals(ListCl.max_by(['hoge', 'foo', 'hehehe', 'yahoo'], len), 'hehehe')
      Assert Equals(ListCl.max_by([20, -50, -15, 30], abs), -50)
    End
  End

  Describe .min_by()
    It returns a minimum value in the non empty list through the given the callable
      let len = Closure.from_funcname('*len')
      let abs = Closure.from_funcname('*abs')

      Assert Equals(ListCl.min_by(['hoge', 'foo', 'hehehe', 'yahoo'], len), 'foo')
      Assert Equals(ListCl.min_by([20, -50, -15, 30], abs), -15)
    End
  End

  Describe .span()
    It returns a minimum value in the non empty list through the given the callable
      let len = Closure.from_funcname('*len')
      let abs = Closure.from_funcname('*abs')

      Assert Equals(ListCl.min_by(['hoge', 'foo', 'hehehe', 'yahoo'], len), 'foo')
      Assert Equals(ListCl.min_by([20, -50, -15, 30], abs), -15)
    End
  End

  Describe .break()
    Before all
      function! Is5(x) abort
        return a:x is 5
      endfunction

      function! IsOver3(x) abort
        return a:x > 3
      endfunction

      function! IsUnder3(x) abort
        return a:x < 3
      endfunction
    End

    After all
      delfunction Is5
      delfunction IsOver3
      delfunction IsUnder3
    End

    It splits a list into two lists. The latter is from the given callable satisfies.
      let is_5       = Closure.from_funcname('*Is5')
      let is_over_3  = Closure.from_funcname('*IsOver3')
      let is_under_3 = Closure.from_funcname('*IsUnder3')

      Assert Equals(ListCl.break(is_5, [1, 3, 5, 2]), [[1, 3], [5, 2]])
      Assert Equals(ListCl.break(is_over_3, [1, 2, 3, 4, 5]), [[1, 2, 3], [4, 5]])
      Assert Equals(ListCl.break(is_under_3, [1, 2, 3, 4, 5]), [[], [1, 2, 3, 4, 5]])
    End
  End

  Describe .take_while()
    Before all
      function! IsUnder5(x) abort
        return a:x < 5
      endfunction

      function! IsOver3(x) abort
        return a:x > 3
      endfunction

      function! IsUnder3(x) abort
        return a:x < 3
      endfunction
    End

    After all
      delfunction IsUnder5
      delfunction IsOver3
      delfunction IsUnder3
    End

    It takes elements while an element satisfies given the callable
      let is_under_5 = Closure.from_funcname('*IsUnder5')
      let is_over_3  = Closure.from_funcname('*IsOver3')
      let is_under_3 = Closure.from_funcname('*IsUnder3')

      Assert Equals(ListCl.take_while(is_under_5, [1, 3, 5, 2]), [1, 3])
      Assert Equals(ListCl.take_while(is_over_3, [1, 2, 3, 4, 5]), [])
      Assert Equals(ListCl.take_while(is_under_3, [1, 2, 3, 4, 5]), [1, 2])
    End
  End
End

" vim:ts=2:sw=2:et
