Describe Stream
  Before all
    let Stream = vital#vital#import('Stream')
    let Closure = vital#vital#import('Data.Closure')

    function! Id(n) abort
      return a:n
    endfunction
    function! Succ(n) abort
      return a:n + 1
    endfunction
    function! IsEven(n) abort
      return a:n % 2 == 0
    endfunction
    function! Answer() abort
      return 42
    endfunction
  End

  After all
    delfunction Id
    delfunction Succ
    delfunction Answer
  End

  Describe .has_characteristics()
    It checks if the stream has certain characteristic
      let s = Stream.from_list([], Stream.ORDERED() + Stream.DISTINCT() + Stream.SORTED() + Stream.SIZED() + Stream.IMMUTABLE())
      Assert Equals(s.has_characteristics(Stream.ORDERED()), 1)
      Assert Equals(s.has_characteristics(Stream.DISTINCT()), 1)
      Assert Equals(s.has_characteristics(Stream.SORTED()), 1)
      Assert Equals(s.has_characteristics(Stream.SIZED()), 1)
      Assert Equals(s.has_characteristics(Stream.IMMUTABLE()), 1)
      unlet s
    End

    It can check multiple flags at once
      let s = Stream.from_list([], Stream.ORDERED() + Stream.DISTINCT() + Stream.SORTED() + Stream.SIZED() + Stream.IMMUTABLE())
      Assert Equals(
      \ s.has_characteristics([
      \   Stream.ORDERED(),
      \   Stream.DISTINCT(),
      \   Stream.SORTED(),
      \   Stream.SIZED(),
      \   Stream.IMMUTABLE()]),
      \ 1)
      Assert Equals(Stream.of(1,2,3).has_characteristics([]), 0)
      unlet s
    End
  End

  Describe .of()
    It constructs stream from arguments
      Assert Equals(Stream.of().count(), 0)
      Assert Equals(Stream.of().to_list(), [])
      Assert Equals(Stream.of(1).count(), 1)
      Assert Equals(Stream.of(1).to_list(), [1])
      Assert Equals(Stream.of(1,2,3).count(), 3)
      Assert Equals(Stream.of(1,2,3).to_list(), [1,2,3])
    End

    It creates stream with characteristics
      let s = Stream.of(1,2,3)
      Assert Equals(s.has_characteristics(Stream.ORDERED()), 1)
      Assert Equals(s.has_characteristics(Stream.DISTINCT()), 0)
      Assert Equals(s.has_characteristics(Stream.SORTED()), 0)
      Assert Equals(s.has_characteristics(Stream.SIZED()), 1)
      Assert Equals(s.has_characteristics(Stream.IMMUTABLE()), 1)
      unlet s
    End
  End

  Describe .chars()
    It constructs stream of each character from String
      Assert Equals(Stream.chars("").count(), 0)
      Assert Equals(Stream.chars("").to_list(), [])
      Assert Equals(Stream.chars("a").count(), 1)
      Assert Equals(Stream.chars("a").to_list(), ['a'])
      Assert Equals(Stream.chars("abc").count(), 3)
      Assert Equals(Stream.chars("abc").to_list(), ['a', 'b', 'c'])
    End

    It constructs stream of each character from String with characteristics
      let s = Stream.chars("abc", 0)
      Assert Equals(s.has_characteristics(Stream.ORDERED()), 0)
      Assert Equals(s.has_characteristics(Stream.DISTINCT()), 0)
      Assert Equals(s.has_characteristics(Stream.SORTED()), 0)
      Assert Equals(s.has_characteristics(Stream.SIZED()), 0)
      Assert Equals(s.has_characteristics(Stream.IMMUTABLE()), 0)
      let s = Stream.chars("abc", Stream.ORDERED() + Stream.DISTINCT() + Stream.SORTED() + Stream.SIZED() + Stream.IMMUTABLE())
      Assert Equals(s.has_characteristics(Stream.ORDERED()), 1)
      Assert Equals(s.has_characteristics(Stream.DISTINCT()), 1)
      Assert Equals(s.has_characteristics(Stream.SORTED()), 1)
      Assert Equals(s.has_characteristics(Stream.SIZED()), 1)
      Assert Equals(s.has_characteristics(Stream.IMMUTABLE()), 1)
      unlet s
    End
  End

  Describe .lines()
    It constructs stream of each line from String
      Assert Equals(Stream.lines("").to_list(), [])
      Assert Equals(Stream.lines("foo").to_list(), ['foo'])
      Assert Equals(Stream.lines("foo\nbar").to_list(), ['foo', 'bar'])
      Assert Equals(Stream.lines("foo\n\nbar").to_list(), ['foo', '', 'bar'])
      Assert Equals(Stream.lines("\nfoo\nbar").to_list(), ['', 'foo', 'bar'])
      Assert Equals(Stream.lines("\n\nfoo\nbar").to_list(), ['', '', 'foo', 'bar'])
      Assert Equals(Stream.lines("foo\nbar\n").to_list(), ['foo', 'bar', ''])
      Assert Equals(Stream.lines("foo\nbar\n\n").to_list(), ['foo', 'bar', '', ''])
    End

    It constructs stream of each line from String with characteristics
      let s = Stream.lines("abc", 0)
      Assert Equals(s.has_characteristics(Stream.ORDERED()), 0)
      Assert Equals(s.has_characteristics(Stream.DISTINCT()), 0)
      Assert Equals(s.has_characteristics(Stream.SORTED()), 0)
      Assert Equals(s.has_characteristics(Stream.SIZED()), 0)
      Assert Equals(s.has_characteristics(Stream.IMMUTABLE()), 0)
      let s = Stream.lines("abc", Stream.ORDERED() + Stream.DISTINCT() + Stream.SORTED() + Stream.SIZED() + Stream.IMMUTABLE())
      Assert Equals(s.has_characteristics(Stream.ORDERED()), 1)
      Assert Equals(s.has_characteristics(Stream.DISTINCT()), 1)
      Assert Equals(s.has_characteristics(Stream.SORTED()), 1)
      Assert Equals(s.has_characteristics(Stream.SIZED()), 1)
      Assert Equals(s.has_characteristics(Stream.IMMUTABLE()), 1)
      unlet s
    End
  End

  Describe .from_list()
    It constructs stream from List
      Assert Equals(Stream.from_list([]).count(), 0)
      Assert Equals(Stream.from_list([]).to_list(), [])
      Assert Equals(Stream.from_list([1]).count(), 1)
      Assert Equals(Stream.from_list([1]).to_list(), [1])
      Assert Equals(Stream.from_list([1,2,3]).count(), 3)
      Assert Equals(Stream.from_list([1,2,3]).to_list(), [1,2,3])
    End

    It creates stream with characteristics
      let s = Stream.from_list([1,2,3])
      Assert Equals(s.has_characteristics(Stream.ORDERED()), 1)
      Assert Equals(s.has_characteristics(Stream.DISTINCT()), 0)
      Assert Equals(s.has_characteristics(Stream.SORTED()), 0)
      Assert Equals(s.has_characteristics(Stream.SIZED()), 1)
      Assert Equals(s.has_characteristics(Stream.IMMUTABLE()), 1)
      unlet s
    End

    It constructs stream from List with characteristics
      let s = Stream.from_list([1,2,3], 0)
      Assert Equals(s.has_characteristics(Stream.ORDERED()), 0)
      Assert Equals(s.has_characteristics(Stream.DISTINCT()), 0)
      Assert Equals(s.has_characteristics(Stream.SORTED()), 0)
      Assert Equals(s.has_characteristics(Stream.SIZED()), 0)
      Assert Equals(s.has_characteristics(Stream.IMMUTABLE()), 0)
      let s = Stream.from_list([1,2,3], Stream.ORDERED() + Stream.DISTINCT() + Stream.SORTED() + Stream.SIZED() + Stream.IMMUTABLE())
      Assert Equals(s.has_characteristics(Stream.ORDERED()), 1)
      Assert Equals(s.has_characteristics(Stream.DISTINCT()), 1)
      Assert Equals(s.has_characteristics(Stream.SORTED()), 1)
      Assert Equals(s.has_characteristics(Stream.SIZED()), 1)
      Assert Equals(s.has_characteristics(Stream.IMMUTABLE()), 1)
      unlet s
    End
  End

  Describe .from_dict()
    It constructs stream from Dictionary
      Assert Equals(Stream.from_dict({}).count(), 0)
      Assert Equals(Stream.from_dict({}).to_list(), [])
      Assert Equals(Stream.from_dict({"foo": 1}).count(), 1)
      Assert Equals(Stream.from_dict({"foo": 1}).to_list(), [["foo", 1]])
      Assert Equals(Stream.from_dict(
      \ {"foo": 1, "bar": 3, "baz": 2}).count(),
      \ 3)
      Assert Equals(
      \ sort(Stream.from_dict({"foo": 1, "bar": 3, "baz": 2}).to_list()),
      \ [["bar", 3], ["baz", 2], ["foo", 1]])
    End

    It creates stream with characteristics
      let s = Stream.from_dict({"foo": 1, "bar": 3, "baz": 2})
      Assert Equals(s.has_characteristics(Stream.ORDERED()), 0)
      Assert Equals(s.has_characteristics(Stream.DISTINCT()), 1)
      Assert Equals(s.has_characteristics(Stream.SORTED()), 0)
      Assert Equals(s.has_characteristics(Stream.SIZED()), 1)
      Assert Equals(s.has_characteristics(Stream.IMMUTABLE()), 1)
      unlet s
    End

    It constructs stream from Dictionary with characteristics
      let s = Stream.from_list({"foo": 1}, 0)
      Assert Equals(s.has_characteristics(Stream.ORDERED()), 0)
      Assert Equals(s.has_characteristics(Stream.DISTINCT()), 0)
      Assert Equals(s.has_characteristics(Stream.SORTED()), 0)
      Assert Equals(s.has_characteristics(Stream.SIZED()), 0)
      Assert Equals(s.has_characteristics(Stream.IMMUTABLE()), 0)
      let s = Stream.from_list({"foo": 1}, Stream.ORDERED() + Stream.DISTINCT() + Stream.SORTED() + Stream.SIZED() + Stream.IMMUTABLE())
      Assert Equals(s.has_characteristics(Stream.ORDERED()), 1)
      Assert Equals(s.has_characteristics(Stream.DISTINCT()), 1)
      Assert Equals(s.has_characteristics(Stream.SORTED()), 1)
      Assert Equals(s.has_characteristics(Stream.SIZED()), 1)
      Assert Equals(s.has_characteristics(Stream.IMMUTABLE()), 1)
      unlet s
    End
  End

  Describe .empty()
    It constructs empty stream
      Assert Equals(Stream.empty().count(), Stream.of().count())
      Assert Equals(Stream.empty().to_list(), Stream.of().to_list())
    End

    It creates stream with characteristics
      let s = Stream.empty()
      Assert Equals(s.has_characteristics(Stream.ORDERED()), 1)
      Assert Equals(s.has_characteristics(Stream.DISTINCT()), 0)
      Assert Equals(s.has_characteristics(Stream.SORTED()), 0)
      Assert Equals(s.has_characteristics(Stream.SIZED()), 1)
      Assert Equals(s.has_characteristics(Stream.IMMUTABLE()), 1)
      unlet s
    End
  End

  Describe .range()
    It constructs stream from range
      Assert Equals(
      \   Stream.range(1, 0).to_list(),
      \   [])
      Assert Equals(
      \   Stream.range(1, 1).to_list(),
      \   [1])
      Assert Equals(
      \   Stream.range(1, 2).to_list(),
      \   [1,2])
      Assert Equals(
      \   Stream.range(1, 4).to_list(),
      \   [1,2,3,4])
    End

    It constructs limited range when .limit() was specified
      Assert Equals(
      \   Stream.range(1, 1/0).limit(5).to_list(),
      \   [1,2,3,4,5])
      Assert Equals(
      \   Stream.range(5, 1/0).limit(5).to_list(),
      \   [5,6,7,8,9])
    End

    It creates stream with characteristics
      let s = Stream.range(1,10)
      Assert Equals(s.has_characteristics(Stream.ORDERED()), 1)
      Assert Equals(s.has_characteristics(Stream.DISTINCT()), 1)
      Assert Equals(s.has_characteristics(Stream.SORTED()), 1)
      Assert Equals(s.has_characteristics(Stream.SIZED()), 1)
      Assert Equals(s.has_characteristics(Stream.IMMUTABLE()), 1)
      unlet s
    End
  End

  Describe .iterate()
    It constructs infinite stream with initial value and function
      Assert Equals(
      \   Stream.iterate(1, 'v:val').limit(3).to_list(),
      \   [1,1,1])
      Assert Equals(
      \   Stream.iterate(5, 'v:val + 1').limit(3).to_list(),
      \   [5,6,7])
    End

    It constructs infinite stream by funcref
      Assert Equals(
      \   Stream.iterate(1, function('Id')).limit(3).to_list(),
      \   [1,1,1])
      Assert Equals(
      \   Stream.iterate(5, function('Succ')).limit(3).to_list(),
      \   [5,6,7])
    End

    It constructs infinite stream by Data.Closure
      Assert Equals(
      \   Stream.iterate(1, Closure.from_expr('a:1')).limit(3).to_list(),
      \   [1,1,1])
      Assert Equals(
      \   Stream.iterate(5, Closure.from_expr('a:1 + 1')).limit(3).to_list(),
      \   [5,6,7])
    End

    It creates stream with characteristics
      let s = Stream.iterate(1, 'v:val + 1')
      Assert Equals(s.has_characteristics(Stream.ORDERED()), 1)
      Assert Equals(s.has_characteristics(Stream.DISTINCT()), 0)
      Assert Equals(s.has_characteristics(Stream.SORTED()), 0)
      Assert Equals(s.has_characteristics(Stream.SIZED()), 0)
      Assert Equals(s.has_characteristics(Stream.IMMUTABLE()), 1)
      unlet s
    End
  End

  Describe .generate()
    It constructs infinite stream
      Assert Equals(
      \ Stream.generate('42').limit(5).to_list(),
      \ [42, 42, 42, 42, 42])
    End

    It constructs infinite stream by funcref
      Assert Equals(
      \ Stream.generate(function('Answer')).limit(5).to_list(),
      \ [42, 42, 42, 42, 42])
    End

    It constructs infinite stream by Data.Closure
      Assert Equals(
      \ Stream.generate(Closure.from_expr('42')).limit(5).to_list(),
      \ [42, 42, 42, 42, 42])
    End
  End

  Describe .zip()
    It constructs infinite stream with function
      Assert Equals(
        \Stream.zip(
          \Stream.empty(),
          \Stream.empty())
        \.to_list(),
        \[])

      Assert Equals(
        \Stream.zip(
          \Stream.empty(),
          \Stream.of(1))
        \.to_list(),
        \[])

      Assert Equals(
        \Stream.zip(
          \Stream.of(1,2,3),
          \Stream.of(4,5,6))
        \.to_list(),
        \[[1,4], [2,5], [3,6]])

      Assert Equals(
        \Stream.zip(
          \Stream.of(1,2),
          \Stream.of(4,5,6))
        \.to_list(),
        \[[1,4], [2,5]])

      Assert Equals(
        \Stream.zip(
          \Stream.of(1,2,3),
          \Stream.of(4,5))
        \.to_list(),
        \[[1,4], [2,5]])

      Assert Equals(
        \Stream.zip(
          \Stream.of(1),
          \Stream.of())
        \.to_list(),
        \[])

      Assert Equals(
        \Stream.zip(
          \Stream.of(),
          \Stream.of(1))
        \.to_list(),
        \[])

      Assert Equals(
        \Stream.zip(
          \Stream.iterate(1, 'v:val + 1'),
          \Stream.of(5, 4, 3, 2, 1))
        \.limit(5).to_list(),
        \[[1,5], [2,4], [3,3], [4,2], [5,1]])
    End

    It constructs infinite stream with function
      Assert Equals(
        \Stream.of(1,2,3).zip(Stream.of(4,5,6)).to_list(),
        \[[1,4], [2,5], [3,6]])
    End

    It constructs stream from String with characteristics
      " Use or() for SIZED flag. Use and() for other flags
      let s = Stream.zip(Stream.of(1,2,3), Stream.of(4,5,6))
      Assert Equals(s.has_characteristics(Stream.ORDERED()), 1)
      Assert Equals(s.has_characteristics(Stream.DISTINCT()), 0)
      Assert Equals(s.has_characteristics(Stream.SORTED()), 0)
      Assert Equals(s.has_characteristics(Stream.SIZED()), 1)
      Assert Equals(s.has_characteristics(Stream.IMMUTABLE()), 1)
      let s = Stream.zip(Stream.iterate(0, 'v:val + 1'), Stream.of(1,2,3))
      Assert Equals(s.has_characteristics(Stream.ORDERED()), 1)
      Assert Equals(s.has_characteristics(Stream.DISTINCT()), 0)
      Assert Equals(s.has_characteristics(Stream.SORTED()), 0)
      Assert Equals(s.has_characteristics(Stream.SIZED()), 1)
      Assert Equals(s.has_characteristics(Stream.IMMUTABLE()), 1)
      unlet s
    End

    It constructs stream with 3 or more than streams
      Assert Equals(
          \Stream.zip(Stream.of(1,2,3), Stream.of(4,5,6), Stream.of(7,8,9))
                \.to_list(),
          \[[1,4,7], [2,5,8], [3,6,9]])

      Assert Equals(
          \Stream.of(1,2,3).zip(Stream.of(4,5,6), Stream.of(7,8,9))
                \.to_list(),
          \[[1,4,7], [2,5,8], [3,6,9]])

      Assert Equals(
          \Stream.zip(Stream.of(1), Stream.of(4,5,6), Stream.of(7,8,9))
                \.to_list(),
          \[[1,4,7]])

      Assert Equals(
          \Stream.of(1).zip(Stream.of(4,5,6), Stream.of(7,8,9))
                \.to_list(),
          \[[1,4,7]])

      Assert Equals(
          \Stream.zip(
              \Stream.iterate(1, 'v:val + 1'),
              \Stream.of(4,5,6),
              \Stream.of(7,8,9)).to_list(),
          \[[1,4,7], [2,5,8], [3,6,9]])

      Assert Equals(
          \Stream.iterate(1, 'v:val + 1').zip(
              \Stream.of(4,5,6),
              \Stream.of(7,8,9)).to_list(),
          \[[1,4,7], [2,5,8], [3,6,9]])
    End

    It constructs stream with 3 or more than streams with characteristics
      " Use or() for SIZED flag. Use and() for other flags
      let s = Stream.zip(Stream.of(1,2,3), Stream.of(4,5,6), Stream.of(7,8,9))
      Assert Equals(s.has_characteristics(Stream.ORDERED()), 1)
      Assert Equals(s.has_characteristics(Stream.DISTINCT()), 0)
      Assert Equals(s.has_characteristics(Stream.SORTED()), 0)
      Assert Equals(s.has_characteristics(Stream.SIZED()), 1)
      Assert Equals(s.has_characteristics(Stream.IMMUTABLE()), 1)
      let s = Stream.zip(Stream.iterate(0, 'v:val + 1'), Stream.of(1,2,3), Stream.of(4,5,6))
      Assert Equals(s.has_characteristics(Stream.ORDERED()), 1)
      Assert Equals(s.has_characteristics(Stream.DISTINCT()), 0)
      Assert Equals(s.has_characteristics(Stream.SORTED()), 0)
      Assert Equals(s.has_characteristics(Stream.SIZED()), 1)
      Assert Equals(s.has_characteristics(Stream.IMMUTABLE()), 1)
      unlet s
    End
  End

  Describe .zip_with_index()
    It constructs infinite stream with function
      Assert Equals(
      \ Stream.empty().zip_with_index().to_list(),
      \ [])

      Assert Equals(
      \ Stream.of(4,5,6).zip_with_index().to_list(),
      \ [[0,4], [1,5], [2,6]])
    End
  End

  Describe .concat()
    It constructs infinite stream with function
      Assert Equals(
        \Stream.concat(
          \Stream.of(1,2,3),
          \Stream.of(4,5))
        \.to_list(),
        \[1,2,3,4,5])

      Assert Equals(
        \Stream.concat(
          \Stream.of(1,2,3),
          \Stream.of())
        \.to_list(),
        \[1,2,3])

      Assert Equals(
        \Stream.concat(
          \Stream.of(),
          \Stream.of(4,5))
        \.to_list(),
        \[4,5])

      Assert Equals(
        \Stream.concat(
          \Stream.iterate(1, 'v:val + 1'),
          \Stream.of('this stream cannot be merged...'))
        \.limit(5).to_list(),
        \[1,2,3,4,5])

      Assert Equals(
        \Stream.concat(
          \Stream.of(1,2,3),
          \Stream.iterate(4, 'v:val + 1'))
        \.limit(5).to_list(),
        \[1,2,3,4,5])
    End

    It constructs infinite stream with function (method version)
      Assert Equals(
        \Stream.of(1,2,3).concat(Stream.of(4,5)).to_list(),
        \[1,2,3,4,5])
    End
  End

  Describe .limit()
    It raises negative number argument
      try
        call Stream.of(1,2,3,4,5).limit(-1)
        Assert 0
      catch /vital: Stream: limit(n): n must be 0 or positive/
        Assert 1
      endtry
      try
        call Stream.of(1,2,3,4,5).limit(0)
        Assert 1
      catch /vital: Stream: limit(n): n must be 0 or positive/
        Assert 0
      endtry
    End

    It limits stream
      Assert Equals(Stream.of(1,2,3,4,5).limit(0).to_list(), [])
      Assert Equals(Stream.of(1,2,3,4,5).limit(3).to_list(), [1,2,3])
      Assert Equals(Stream.of(3,4,5,6,7).limit(3).to_list(), [3,4,5])
      Assert Equals(Stream.iterate(1, 'v:val + 1').limit(3).to_list(), [1,2,3])
    End

    It sets SIZED characteristic
      let s = Stream.of(3,4,5,6,7).limit(3)
      Assert Equals(s.has_characteristics(Stream.ORDERED()), 1)
      Assert Equals(s.has_characteristics(Stream.DISTINCT()), 0)
      Assert Equals(s.has_characteristics(Stream.SORTED()), 0)
      Assert Equals(s.has_characteristics(Stream.SIZED()), 1)
      Assert Equals(s.has_characteristics(Stream.IMMUTABLE()), 1)
      let s = Stream.iterate(1, 'v:val + 1').limit(3)
      Assert Equals(s.has_characteristics(Stream.ORDERED()), 1)
      Assert Equals(s.has_characteristics(Stream.DISTINCT()), 0)
      Assert Equals(s.has_characteristics(Stream.SORTED()), 0)
      Assert Equals(s.has_characteristics(Stream.SIZED()), 1)
      Assert Equals(s.has_characteristics(Stream.IMMUTABLE()), 1)
    End

    It must not reuse stream
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.limit(3)
        Assert 1
      catch
        Assert 0
      endtry
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.limit(3).to_list()
        Assert 0
      catch
        Assert 1
      endtry
      unlet s
    End
  End

  Describe .skip()
    It raises negative number argument
      try
        call Stream.of(1,2,3,4,5).skip(-1)
        Assert 0
      catch /vital: Stream: skip(n): n must be 0 or positive/
        Assert 1
      endtry
      try
        call Stream.of(1,2,3,4,5).skip(0)
        Assert 1
      catch /vital: Stream: skip(n): n must be 0 or positive/
        Assert 0
      endtry
    End

    It limits stream
      Assert Equals(Stream.of(1,2,3,4,5).skip(0).to_list(), [1,2,3,4,5])
      Assert Equals(Stream.of(1,2,3,4,5).skip(3).to_list(), [4,5])
      Assert Equals(Stream.of(3,4,5,6,7).skip(3).to_list(), [6,7])
      Assert Equals(Stream.iterate(1, 'v:val + 1').skip(3).limit(3).to_list(), [4,5,6])
    End

    It must not reuse stream
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.skip(3)
        Assert 1
      catch
        Assert 0
      endtry
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.skip(3).to_list()
        Assert 0
      catch
        Assert 1
      endtry
      unlet s
    End
  End

  Describe .peek()
    It peeks stream
      let g:peek = []
      Assert Equals(Stream.of(1,2,3).peek('add(g:peek, v:val)').to_list(), [1,2,3])
      Assert Equals(g:peek, [1,2,3])
      unlet g:peek
    End

    It peeks stream by funcref
      let g:peek = []
      function! Add(v) abort
        let g:peek += [a:v]
      endfunction
      Assert Equals(Stream.of(1,2,3).peek(function('Add')).to_list(), [1,2,3])
      Assert Equals(g:peek, [1,2,3])
      unlet g:peek
      delfunction Add
    End

    It peeks stream by Data.Closure
      let g:peek = []
      Assert Equals(Stream.of(1,2,3).peek(Closure.from_command('let g:peek += [a:1]')).to_list(), [1,2,3])
      Assert Equals(g:peek, [1,2,3])
      unlet g:peek
    End

    It must not reuse stream
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.peek('v:val')
        Assert 1
      catch
        Assert 0
      endtry
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.peek('v:val').to_list()
        Assert 0
      catch
        Assert 1
      endtry
      unlet s
    End
  End

  Describe .foreach()
    It iterates elements in stream
      let g:foreach = []
      Assert Equals(Stream.of(1,2,3).foreach('add(g:foreach, v:val)'), 0)
      Assert Equals(g:foreach, [1,2,3])
      unlet g:foreach
    End

    It peeks stream by funcref
      let g:foreach = []
      function! Add(v) abort
        let g:foreach += [a:v]
      endfunction
      Assert Equals(Stream.of(1,2,3).foreach(function('Add')), 0)
      Assert Equals(g:foreach, [1,2,3])
      unlet g:foreach
      delfunction Add
    End

    It peeks stream by Data.Closure
      let g:foreach = []
      Assert Equals(Stream.of(1,2,3).foreach(Closure.from_command('let g:foreach += [a:1]')), 0)
      Assert Equals(g:foreach, [1,2,3])
      unlet g:foreach
    End

    It must not reuse stream
      try
        let s = Stream.of(1,2,3,4,5)
        call s.foreach('v:val')
        Assert 1
      catch
        Assert 0
      endtry
      try
        let s = Stream.of(1,2,3,4,5)
        call s.foreach('v:val')
        call s.foreach('v:val')
        Assert 0
      catch
        Assert 1
      endtry
      unlet s
    End
  End

  Describe .map()
    It maps stream
      Assert Equals(Stream.empty().map('v:val + 1').to_list(), [])

      Assert Equals(
      \ Stream.iterate(1, 'v:val + 1').map('v:val + 1').limit(3).to_list(),
      \ [2,3,4])
    End

    It maps stream by funcref
      Assert Equals(Stream.empty().map(function('Succ')).to_list(), [])

      Assert Equals(
      \ Stream.iterate(1, 'v:val + 1').map(function('Succ')).limit(3).to_list(),
      \ [2,3,4])
    End

    It maps stream by Data.Closure
      Assert Equals(Stream.empty().map(Closure.from_expr('a:1 + 1')).to_list(), [])

      Assert Equals(
      \ Stream.iterate(1, 'v:val + 1').map(Closure.from_expr('a:1 + 1')).limit(3).to_list(),
      \ [2,3,4])
    End

    It must not reuse stream
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.map('v:val')
        Assert 1
      catch
        Assert 0
      endtry
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.map('v:val').to_list()
        Assert 0
      catch
        Assert 1
      endtry
      unlet s
    End
  End

  Describe .flatmap()
    It flattens mapped stream
      Assert Equals(Stream.empty().flatmap('[v:val]').to_list(), [])

      Assert Equals(
        \Stream.iterate(0, 'v:val + 1')
          \.flatmap('repeat([v:val], v:val)').limit(6).to_list(),
        \[1,2,2,3,3,3])

      Assert Equals(
        \Stream.of(1,2,3)
          \.flatmap('repeat([v:val], v:val)').to_list(),
        \[1,2,2,3,3,3])

      Assert Equals(
        \Stream.of(1,2,3)
          \.flatmap('repeat([v:val], v:val)').limit(6).to_list(),
        \[1,2,2,3,3,3])

      Assert Equals(
        \Stream.of(1,2,3,4,5)
          \.flatmap('repeat([v:val], v:val)').limit(6).to_list(),
        \[1,2,2,3,3,3])

      Assert Equals(
        \Stream.of(0,1,2,3,4,5)
          \.flatmap('v:val % 2 == 0 ? [v:val * 2] : []').limit(3).to_list(),
        \[0, 4, 8])

      Assert Equals(
        \Stream.iterate(0, 'v:val + 1')
          \.flatmap('v:val % 2 == 0 ? [v:val * 2] : []').limit(3).to_list(),
        \[0, 4, 8])
    End

    It flattens mapped stream by funcref
      function! Repeat(n) abort
        return repeat([a:n], a:n)
      endfunction

      Assert Equals(Stream.empty().flatmap(function('Repeat')).to_list(), [])

      Assert Equals(
        \Stream.iterate(0, function('Succ'))
          \.flatmap(function('Repeat')).limit(6).to_list(),
        \[1,2,2,3,3,3])

      delfunction Repeat
    End

    It flattens mapped stream by Data.Closure
      Assert Equals(Stream.empty().flatmap(Closure.from_expr('repeat([a:1], a:1)')).to_list(), [])

      Assert Equals(
        \Stream.iterate(0, Closure.from_expr('a:1 + 1'))
          \.flatmap(Closure.from_expr('repeat([a:1], a:1)')).limit(6).to_list(),
        \[1,2,2,3,3,3])
    End

    It must not reuse stream
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.flatmap('v:val')
        Assert 1
      catch
        Assert 0
      endtry
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.flatmap('v:val').to_list()
        Assert 0
      catch
        Assert 1
      endtry
      unlet s
    End
  End

  Describe .filter()
    It filters stream
      Assert Equals(Stream.empty().filter('v:val % 2 == 0').to_list(), [])

      Assert Equals(
      \ Stream.iterate(0, 'v:val + 1').filter('v:val % 2 == 0').limit(3).to_list(),
      \ [0,2,4])
    End

    It filters stream by funcref
      Assert Equals(Stream.empty().filter(function('IsEven')).to_list(), [])

      Assert Equals(
      \ Stream.iterate(0, 'v:val + 1').filter(function('IsEven')).limit(3).to_list(),
      \ [0,2,4])
    End

    It filters stream by Data.Closure
      Assert Equals(Stream.empty().filter(Closure.from_expr('a:1 % 2 == 0')).to_list(), [])

      Assert Equals(
      \ Stream.iterate(0, 'v:val + 1').filter(Closure.from_expr('a:1 % 2 == 0')).limit(3).to_list(),
      \ [0,2,4])
    End

    It must not reuse stream
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.filter('v:val % 2 == 0')
        Assert 1
      catch
        Assert 0
      endtry
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.filter('v:val % 2 == 0').to_list()
        Assert 0
      catch
        Assert 1
      endtry
      unlet s
    End
  End

  Describe .take_while()
    It takes elements until element is matched
      Assert Equals(Stream.empty().take_while('v:val').to_list(), [])
      Assert Equals(
      \ Stream.range(1, 10).take_while('v:val < 4').to_list(),
      \ [1,2,3])
      Assert Equals(
      \ Stream.range(1, 10).take_while('v:val < 4').limit(2).to_list(),
      \ [1,2])
      Assert Equals(
      \ Stream.iterate(1, 'v:val + 1').take_while('v:val < 4').to_list(),
      \ [1,2,3])
    End

    It takes elements until element is matched by funcref
      function! LessThan4(n) abort
        return a:n < 4
      endfunction

      Assert Equals(Stream.empty().take_while(function('Id')).to_list(), [])
      Assert Equals(
      \ Stream.range(1, 10).take_while(function('LessThan4')).to_list(),
      \ [1,2,3])
      Assert Equals(
      \ Stream.range(1, 10).take_while(function('LessThan4')).limit(2).to_list(),
      \ [1,2])
      Assert Equals(
      \ Stream.iterate(1, function('Succ')).take_while(function('LessThan4')).to_list(),
      \ [1,2,3])

      delfunction LessThan4
    End

    It takes elements until element is matched by Data.Closure
      Assert Equals(Stream.empty().take_while(Closure.from_expr('a:1')).to_list(), [])
      Assert Equals(
      \ Stream.range(1, 10).take_while(Closure.from_expr('a:1 < 4')).to_list(),
      \ [1,2,3])
      Assert Equals(
      \ Stream.range(1, 10).take_while(Closure.from_expr('a:1 < 4')).limit(2).to_list(),
      \ [1,2])
      Assert Equals(
      \ Stream.iterate(1, Closure.from_expr('a:1 + 1')).take_while(Closure.from_expr('a:1 < 4')).to_list(),
      \ [1,2,3])
    End

    It must not reuse stream
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.take_while('v:val')
        Assert 1
      catch
        Assert 0
      endtry
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.take_while('v:val').to_list()
        Assert 0
      catch
        Assert 1
      endtry
      unlet s
    End
  End

  Describe .drop_while()
    It drops elements until element is matched
      Assert Equals(
      \ Stream.empty().drop_while('v:val').to_list(),
      \ [])
      Assert Equals(
      \ Stream.of(1,2,3,4,5).drop_while('v:val < 4').to_list(),
      \ [4,5])
      Assert Equals(
      \ Stream.iterate(1, 'v:val + 1').drop_while('v:val < 4').limit(2).to_list(),
      \ [4,5])
    End

    It drops elements until element is matched by funcref
      function! LessThan4(n) abort
        return a:n < 4
      endfunction

      Assert Equals(
      \ Stream.empty().drop_while(function('Id')).to_list(),
      \ [])
      Assert Equals(
      \ Stream.of(1,2,3,4,5).drop_while(function('LessThan4')).to_list(),
      \ [4,5])
      Assert Equals(
      \ Stream.iterate(1, function('Succ')).drop_while(function('LessThan4')).limit(2).to_list(),
      \ [4,5])

      delfunction LessThan4
    End

    It drops elements until element is matched by Data.Closure
      Assert Equals(
      \ Stream.empty().drop_while(Closure.from_expr('a:1')).to_list(),
      \ [])
      Assert Equals(
      \ Stream.of(1,2,3,4,5).drop_while(Closure.from_expr('a:1 < 4')).to_list(),
      \ [4,5])
      Assert Equals(
      \ Stream.iterate(1, Closure.from_expr('a:1 + 1')).drop_while(Closure.from_expr('a:1 < 4')).limit(2).to_list(),
      \ [4,5])
    End

    It must not reuse stream
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.drop_while('v:val')
        Assert 1
      catch
        Assert 0
      endtry
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.drop_while('v:val').to_list()
        Assert 0
      catch
        Assert 1
      endtry
      unlet s
    End
  End

  Describe .distinct()
    It dedupes elements in stream
      Assert Equals(Stream.of().distinct().to_list(), [])
      Assert Equals(Stream.of(1,2,3).distinct().to_list(), [1,2,3])
      Assert Equals(Stream.of(1,1,2,2,3).distinct().to_list(), [1,2,3])
      Assert Equals(Stream.of(1,2,3,2,3).distinct().to_list(), [1,2,3])
      Assert Equals(Stream.of(3,1,2).distinct().to_list(), [3,1,2])
      Assert Equals(Stream.of(3,3,1,1,2).distinct().to_list(), [3,1,2])
      Assert Equals(Stream.of(3,1,2,1,2).distinct().to_list(), [3,1,2])
    End

    It stops for infinite stream if downstream limited the number elements
      Assert Equals(
      \ Stream.iterate(0, '(v:val + 1) % 3').distinct().limit(6).to_list(),
      \ [0,1,2])
    End
  End

  Describe .sorted()
    It sorts elements in stream without comparator
      Assert Equals(Stream.of().sorted().to_list(), [])
      Assert Equals(Stream.of(2,1,3).sorted().to_list(), [1,2,3])
      Assert Equals(Stream.of(2,1,3,2,1).sorted().to_list(), [1,1,2,2,3])
      Assert Equals(
      \ Stream.iterate(3, 'v:val - 1').limit(3).sorted().to_list(),
      \ [1,2,3])
      Assert Equals(Stream.of(4,5,6,1,2,3).sorted().limit(3).to_list(), [1,2,3])
    End

    It sorts elements in stream with comparator
      let by_desc = 'v:val[0] > v:val[1] ? -1 : v:val[0] ==# v:val[1] ? 0 : 1'
      Assert Equals(Stream.of().sorted(by_desc).to_list(), [])
      Assert Equals(Stream.of(2,1,3).sorted(by_desc).to_list(), [3,2,1])
      Assert Equals(Stream.of(2,1,3,2,1).sorted(by_desc).to_list(), [3,2,2,1,1])
      Assert Equals(
      \ Stream.iterate(1, 'v:val + 1').limit(3).sorted(by_desc).to_list(),
      \ [3,2,1])
      unlet by_desc
    End

    It sorts elements in stream with comparator by funcref
      let by_desc = Closure.from_expr('a:1 > a:2 ? -1 : a:1 ==# a:2 ? 0 : 1')
      Assert Equals(Stream.of().sorted(by_desc).to_list(), [])
      Assert Equals(Stream.of(2,1,3).sorted(by_desc).to_list(), [3,2,1])
      Assert Equals(Stream.of(2,1,3,2,1).sorted(by_desc).to_list(), [3,2,2,1,1])
      Assert Equals(
      \ Stream.iterate(1, 'v:val + 1').limit(3).sorted(by_desc).to_list(),
      \ [3,2,1])
      unlet by_desc
    End

    It sets SORTED characteristic
      let s = Stream.of(1,2,3).sorted()
      Assert Equals(s.has_characteristics(Stream.ORDERED()), 1)
      Assert Equals(s.has_characteristics(Stream.DISTINCT()), 0)
      Assert Equals(s.has_characteristics(Stream.SORTED()), 1)
      Assert Equals(s.has_characteristics(Stream.SIZED()), 1)
      Assert Equals(s.has_characteristics(Stream.IMMUTABLE()), 1)
    End
  End

  Describe .reduce()
    It raises exception for empty stream
      try
        call Stream.empty().reduce('v:val')
        Assert 0
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 1
      endtry
    End

    It reduces stream
      Assert Equals(Stream.empty().reduce('v:val', 42), 42)
      Assert Equals(Stream.of(1,2,3,4,5).reduce('v:val[0] + v:val[1]'), 15)
      Assert Equals(Stream.of(1,2,3,4,5).reduce('v:val[0] + v:val[1]', 0), 15)
    End

    It reduces stream by funcref
      function! Plus(a, b) abort
        return a:a + a:b
      endfunction

      Assert Equals(Stream.empty().reduce(function('Id'), 42), 42)
      Assert Equals(Stream.of(1,2,3,4,5).reduce(function('Plus')), 15)
      Assert Equals(Stream.of(1,2,3,4,5).reduce(function('Plus'), 0), 15)

      delfunction Plus
    End

    It reduces stream by Data.Closure
      Assert Equals(Stream.empty().reduce(Closure.from_expr('a:1'), 42), 42)
      Assert Equals(Stream.of(1,2,3,4,5).reduce(Closure.from_operator('+')), 15)
      Assert Equals(Stream.of(1,2,3,4,5).reduce(Closure.from_operator('+'), 0), 15)
    End
  End

  Describe .max()
    It raises exception for empty stream
      try
        call Stream.empty().max()
        Assert 0
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 1
      endtry
      try
        Assert Equals(Stream.empty().max(42), 42)
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 0
      endtry
    End

    It returns max value in stream
      Assert Equals(Stream.of(1,2,3,4,5).max(), 5)
    End
  End

  Describe .max_by()
    It raises exception for empty stream
      try
        call Stream.empty().max_by('v:val')
        Assert 0
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 1
      endtry
      try
        Assert Equals(Stream.empty().max_by('v:val', 42), 42)
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 0
      endtry
    End

    It returns max value in stream
      Assert Equals(Stream.of('aaa', 'bb', '').max_by('len(v:val)'), 'aaa')
    End

    It returns max value in stream by funcref
      function! Len(v) abort
        return len(a:v)
      endfunction

      Assert Equals(Stream.of('aaa', 'bb', '').max_by(function('Len')), 'aaa')

      delfunction Len
    End

    It returns max value in stream by Data.Closure
      Assert Equals(Stream.of('aaa', 'bb', '').max_by(Closure.from_funcname('len')), 'aaa')
    End
  End

  Describe .min()
    It raises exception for empty stream
      try
        call Stream.empty().min()
        Assert 0
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 1
      endtry
      try
        Assert Equals(Stream.empty().min(42), 42)
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 0
      endtry
    End

    It returns min value in stream
      Assert Equals(Stream.of(1,2,3,4,5).min(), 1)
    End
  End

  Describe .min_by()
    It raises exception for empty stream
      try
        call Stream.empty().min_by('v:val')
        Assert 0
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 1
      endtry
      try
        Assert Equals(Stream.empty().min_by('v:val', 42), 42)
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 0
      endtry
    End

    It returns min value in stream
      Assert Equals(Stream.of('aaa', 'bb', '').min_by('len(v:val)'), '')
    End

    It returns min value in stream by funcref
      function! Len(v) abort
        return len(a:v)
      endfunction

      Assert Equals(Stream.of('aaa', 'bb', '').min_by(function('Len')), '')

      delfunction Len
    End

    It returns min value in stream by Data.Closure
      Assert Equals(Stream.of('aaa', 'bb', '').min_by(Closure.from_funcname('len')), '')
    End
  End

  Describe .find_first()
    It raises exception for empty stream
      try
        call Stream.empty().find_first()
        Assert 0
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 1
      endtry
      try
        Assert Equals(Stream.empty().find_first(42), 42)
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 0
      endtry
    End

    It returns the first element in stream
      Assert Equals(Stream.of('aaa', 'bb', '').find_first(), 'aaa')
      Assert Equals(Stream.iterate(1, 'v:val + 1').filter('v:val % 2 == 0').limit(1).find_first(), 2)
    End
  End

  Describe .find()
    It raises exception for empty stream
      try
        call Stream.empty().find('v:val')
        Assert 0
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 1
      endtry
      try
        Assert Equals(Stream.empty().find('v:val', 42), 42)
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 0
      endtry
    End

    It returns the first element matching with given predicate function in stream
      Assert Equals(Stream.iterate(1, 'v:val + 1').find('v:val % 2 == 0'), 2)
    End

    It returns the first element matching with given predicate function in stream by funcref
      Assert Equals(Stream.iterate(1, function('Succ')).find(function('IsEven')), 2)
    End

    It returns the first element matching with given predicate function in stream by Data.Closure
      Assert Equals(Stream.iterate(1, Closure.from_expr('a:1 + 1')).find(Closure.from_expr('a:1 % 2 == 0')), 2)
    End
  End

  Describe .any_match()
    It returns boolean value if any elements are matched in stream
      Assert Equals(Stream.empty().any_match('v:val'), 0)
      Assert Equals(Stream.of(1,2,3).any_match('v:val > 2'), 1)
      Assert Equals(Stream.of(1,2,3).any_match('v:val > 3'), 0)
    End

    It returns boolean value if any elements are matched in stream by funcref
      function! GreaterThan2(n) abort
        return a:n > 2
      endfunction
      function! GreaterThan3(n) abort
        return a:n > 3
      endfunction

      Assert Equals(Stream.empty().any_match(function('Id')), 0)
      Assert Equals(Stream.of(1,2,3).any_match(function('GreaterThan2')), 1)
      Assert Equals(Stream.of(1,2,3).any_match(function('GreaterThan3')), 0)

      delfunction GreaterThan2
      delfunction GreaterThan3
    End

    It returns boolean value if any elements are matched in stream by Data.Closure
      Assert Equals(Stream.empty().any_match(Closure.from_expr('a:1')), 0)
      Assert Equals(Stream.of(1,2,3).any_match(Closure.from_expr('a:1 > 2')), 1)
      Assert Equals(Stream.of(1,2,3).any_match(Closure.from_expr('a:1 > 3')), 0)
    End
  End

  Describe .all_match()
    It returns boolean value if all elements are matched in stream
      Assert Equals(Stream.empty().all_match('v:val'), 1)
      Assert Equals(Stream.of(1,2,3).all_match('v:val > 0'), 1)
      Assert Equals(Stream.of(1,2,3).all_match('v:val > 1'), 0)
    End

    It returns boolean value if all elements are matched in stream by funcref
      function! GreaterThan0(n) abort
        return a:n > 0
      endfunction
      function! GreaterThan1(n) abort
        return a:n > 1
      endfunction

      Assert Equals(Stream.empty().all_match(function('Id')), 1)
      Assert Equals(Stream.of(1,2,3).all_match(function('GreaterThan0')), 1)
      Assert Equals(Stream.of(1,2,3).all_match(function('GreaterThan1')), 0)

      delfunction GreaterThan0
      delfunction GreaterThan1
    End

    It returns boolean value if all elements are matched in stream by Data.Closure
      Assert Equals(Stream.empty().all_match(Closure.from_expr('a:1')), 1)
      Assert Equals(Stream.of(1,2,3).all_match(Closure.from_expr('a:1 > 0')), 1)
      Assert Equals(Stream.of(1,2,3).all_match(Closure.from_expr('a:1 > 1')), 0)
    End
  End

  Describe .none_match()
    It returns boolean value if none elements are matched in stream
      Assert Equals(Stream.empty().none_match('v:val'), 1)
      Assert Equals(Stream.of(1,2,3).none_match('v:val > 3'), 1)
      Assert Equals(Stream.of(1,2,3).none_match('v:val > 2'), 0)
    End

    It returns boolean value if none elements are matched in stream by funcref
      function! GreaterThan3(n) abort
        return a:n > 3
      endfunction
      function! GreaterThan2(n) abort
        return a:n > 2
      endfunction

      Assert Equals(Stream.empty().none_match(function('Id')), 1)
      Assert Equals(Stream.of(1,2,3).none_match(function('GreaterThan3')), 1)
      Assert Equals(Stream.of(1,2,3).none_match(function('GreaterThan2')), 0)

      delfunction GreaterThan3
      delfunction GreaterThan2
    End

    It returns boolean value if none elements are matched in stream by Data.Closure
      Assert Equals(Stream.empty().none_match(Closure.from_expr('a:1')), 1)
      Assert Equals(Stream.of(1,2,3).none_match(Closure.from_expr('a:1 > 3')), 1)
      Assert Equals(Stream.of(1,2,3).none_match(Closure.from_expr('a:1 > 2')), 0)
    End
  End

  Describe .string_join()
    It joins elements in stream
      Assert Equals(Stream.of().string_join(), '')
      Assert Equals(Stream.of(1).string_join(), '1')
      Assert Equals(Stream.of(1,2,3).string_join(), '1 2 3')
      Assert Equals(Stream.of(1,2,3).string_join(','), '1,2,3')
      Assert Equals(Stream.of('foo').string_join(), 'foo')
      Assert Equals(Stream.of('foo', 'bar', 'baz').string_join(), 'foo bar baz')
      Assert Equals(Stream.of('foo', 'bar', 'baz').string_join(','), 'foo,bar,baz')
    End
  End

  Describe .group_by()
    It groups stream
      Assert Equals(Stream.of().group_by('v:val'), {})
      Assert Equals(Stream.of(1).group_by('v:val'), {'1': [1]})
      Assert Equals(Stream.of(1,2,3).group_by('v:val'), {'1': [1], '2': [2], '3': [3]})
      Assert Equals(Stream.of(1,2,3,2,1).group_by('v:val'), {'1': [1,1], '2': [2,2], '3': [3]})
      Assert Equals(Stream.of('foo', 'bar', 'baz').group_by('v:val'), {'foo': ['foo'], 'bar': ['bar'], 'baz': ['baz']})
      Assert Equals(Stream.of('a', 'bb', 'ccc').group_by('len(v:val)'), {'1': ['a'], '2': ['bb'], '3': ['ccc']})
      Assert Equals(Stream.of('a', 'bb', 'ccc', 'ddd').group_by('len(v:val)'), {'1': ['a'], '2': ['bb'], '3': ['ccc', 'ddd']})
    End

    It groups stream by funcref
      function! Len(v) abort
        return len(a:v)
      endfunction

      Assert Equals(Stream.of().group_by(function('Id')), {})
      Assert Equals(Stream.of(1).group_by(function('Id')), {'1': [1]})
      Assert Equals(Stream.of(1,2,3).group_by(function('Id')), {'1': [1], '2': [2], '3': [3]})
      Assert Equals(Stream.of(1,2,3,2,1).group_by(function('Id')), {'1': [1,1], '2': [2,2], '3': [3]})
      Assert Equals(Stream.of('foo', 'bar', 'baz').group_by(function('Id')), {'foo': ['foo'], 'bar': ['bar'], 'baz': ['baz']})
      Assert Equals(Stream.of('a', 'bb', 'ccc').group_by(function('Len')), {'1': ['a'], '2': ['bb'], '3': ['ccc']})
      Assert Equals(Stream.of('a', 'bb', 'ccc', 'ddd').group_by(function('Len')), {'1': ['a'], '2': ['bb'], '3': ['ccc', 'ddd']})

      delfunction Len
    End

    It groups stream by Data.Closure
      let id = Closure.from_expr('a:1')
      let len = Closure.from_funcname('len')

      Assert Equals(Stream.of().group_by(id), {})
      Assert Equals(Stream.of(1).group_by(id), {'1': [1]})
      Assert Equals(Stream.of(1,2,3).group_by(id), {'1': [1], '2': [2], '3': [3]})
      Assert Equals(Stream.of(1,2,3,2,1).group_by(id), {'1': [1,1], '2': [2,2], '3': [3]})
      Assert Equals(Stream.of('foo', 'bar', 'baz').group_by(id), {'foo': ['foo'], 'bar': ['bar'], 'baz': ['baz']})
      Assert Equals(Stream.of('a', 'bb', 'ccc').group_by(len), {'1': ['a'], '2': ['bb'], '3': ['ccc']})
      Assert Equals(Stream.of('a', 'bb', 'ccc', 'ddd').group_by(len), {'1': ['a'], '2': ['bb'], '3': ['ccc', 'ddd']})

      unlet id
      unlet len
    End
  End

  Describe .to_dict()
    It converts elements to Dictionary in stream
      Assert Equals(Stream.of().to_dict('v:val', 'v:val'), {})
      Assert Equals(Stream.of(1).to_dict('v:val', 'v:val'), {'1': 1})
      Assert Equals(Stream.of(1,2,3).to_dict('v:val', 'v:val'), {'1': 1, '2': 2, '3': 3})
      Assert Equals(Stream.of('foo', 'bar', 'baz').to_dict('v:val', 'v:val'), {'foo': 'foo', 'bar': 'bar', 'baz': 'baz'})
      Assert Equals(Stream.of('a', 'bb', 'ccc').to_dict('len(v:val)', 'v:val'), {'1': 'a', '2': 'bb', '3': 'ccc'})
    End

    It converts elements to Dictionary in stream with merge function
      try
        call Stream.of(1,2,3,2,1).to_dict('v:val', 'v:val')
        Assert 0
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '2')/
        Assert 1
      endtry
      try
        Assert Equals(
          \Stream.of(1,2,3,2,1)
            \.to_dict('v:val', '[v:val]', 'v:val[0] + v:val[1]'),
          \{'1': [1,1], '2': [2,2], '3': [3]})
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '2')/
        Assert 0
      endtry

      try
        call Stream.of('a', 'bb', 'ccc', 'ddd').to_dict('len(v:val)', 'v:val')
        Assert 0
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '3')/
        Assert 1
      endtry
      try
        Assert Equals(
          \Stream.of('a', 'bb', 'ccc', 'ddd')
            \.to_dict('len(v:val)', '[v:val]'),
          \{'1': ['a'], '2': ['bb'], '3': ['ccc', 'ddd']})
        Assert 0
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '3')/
        Assert 1
      endtry
    End

    It converts elements to Dictionary in stream by funcref
      function! Len(v) abort
        return len(a:v)
      endfunction

      Assert Equals(Stream.of().to_dict(function('Id'), function('Id')), {})
      Assert Equals(Stream.of(1).to_dict(function('Id'), function('Id')), {'1': 1})
      Assert Equals(Stream.of(1,2,3).to_dict(function('Id'), function('Id')), {'1': 1, '2': 2, '3': 3})
      Assert Equals(Stream.of('foo', 'bar', 'baz').to_dict(function('Id'), function('Id')), {'foo': 'foo', 'bar': 'bar', 'baz': 'baz'})
      Assert Equals(Stream.of('a', 'bb', 'ccc').to_dict(function('Len'), function('Id')), {'1': 'a', '2': 'bb', '3': 'ccc'})

      delfunction Len
    End

    It converts elements to Dictionary in stream with merge function by funcref
      function! Len(v) abort
        return len(a:v)
      endfunction
      function! List(v) abort
        return [a:v]
      endfunction
      function! Plus(a, b) abort
        return a:a + a:b
      endfunction

      try
        call Stream.of(1,2,3,2,1).to_dict(function('Id'), function('Id'))
        Assert 0
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '2')/
        Assert 1
      endtry
      try
        Assert Equals(
          \Stream.of(1,2,3,2,1)
            \.to_dict(function('Id'), function('List'), function('Plus')),
          \{'1': [1,1], '2': [2,2], '3': [3]})
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '2')/
        Assert 0
      endtry

      try
        call Stream.of('a', 'bb', 'ccc', 'ddd').to_dict(function('Len'), function('Id'))
        Assert 0
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '3')/
        Assert 1
      endtry
      try
        Assert Equals(
          \Stream.of('a', 'bb', 'ccc', 'ddd')
            \.to_dict(function('Len'), function('List')),
          \{'1': ['a'], '2': ['bb'], '3': ['ccc', 'ddd']})
        Assert 0
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '3')/
        Assert 1
      endtry

      delfunction Len
      delfunction List
      delfunction Plus
    End

    It converts elements to Dictionary in stream by Data.Closure
      let id = Closure.from_expr('a:1')
      let len = Closure.from_funcname('len')

      Assert Equals(Stream.of().to_dict(id, id), {})
      Assert Equals(Stream.of(1).to_dict(id, id), {'1': 1})
      Assert Equals(Stream.of(1,2,3).to_dict(id, id), {'1': 1, '2': 2, '3': 3})
      Assert Equals(Stream.of('foo', 'bar', 'baz').to_dict(id, id), {'foo': 'foo', 'bar': 'bar', 'baz': 'baz'})
      Assert Equals(Stream.of('a', 'bb', 'ccc').to_dict(len, id), {'1': 'a', '2': 'bb', '3': 'ccc'})

      unlet id
      unlet len
    End

    It converts elements to Dictionary in stream with merge function by Data.Closure
      let id = Closure.from_expr('a:1')
      let len = Closure.from_funcname('len')
      let list = Closure.from_expr('[a:1]')
      let plus = Closure.from_operator('+')

      try
        call Stream.of(1,2,3,2,1).to_dict(id, id)
        Assert 0
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '2')/
        Assert 1
      endtry
      try
        Assert Equals(
          \Stream.of(1,2,3,2,1)
            \.to_dict(id, list, plus),
          \{'1': [1,1], '2': [2,2], '3': [3]})
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '2')/
        Assert 0
      endtry

      try
        call Stream.of('a', 'bb', 'ccc', 'ddd').to_dict(len, id)
        Assert 0
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '3')/
        Assert 1
      endtry
      try
        Assert Equals(
          \Stream.of('a', 'bb', 'ccc', 'ddd')
            \.to_dict(len, list),
          \{'1': ['a'], '2': ['bb'], '3': ['ccc', 'ddd']})
        Assert 0
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '3')/
        Assert 1
      endtry

      unlet id
      unlet len
      unlet list
      unlet plus
    End
  End

  Describe .sum()
    It sums elements in stream
      Assert Equals(Stream.of().sum(), 0)
      Assert Equals(Stream.of(1,2,3).sum(), 6)
    End
  End

  Describe .average()
    It averages elements in stream
      try
        Assert Equals(Stream.of().average(), 0)
        Assert 0
      catch /vital: Stream: average(): empty stream cannot be average()d/
        Assert 1
      endtry
      Assert Equals(Stream.of(2).average(), 2)
      Assert Equals(Stream.of(1,2,3).average(), 2)
      Assert Equals(Stream.of(-5,0,5).average(), 0)
    End
  End

  Describe .count()
    It counts elements in stream
      Assert Equals(Stream.of().count(), 0)
      Assert Equals(Stream.of(1,2,3).count(), 3)
      Assert Equals(Stream.iterate(1, 'v:val + 1').count(), 1/0)
    End
  End

  Describe .to_list()
    It converts stream to a List
      Assert Equals(Stream.of(1,2,3).to_list(), [1,2,3])
    End

    It must not reuse stream
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.to_list()
        Assert 0
      catch
        Assert 1
      endtry
      unlet s
    End
  End

  Describe .generator()
    It supports interface of generator function like Java's Spliterator
      let generator = {}
      function! generator.yield(times, NONE) abort
        if a:times >= 3
          return a:NONE
        endif
        return a:times
      endfunction

      Assert Equals(Stream.generator(generator).to_list(), [0,1,2])
      unlet generator
    End

    It supports interface of infinite generator function like Java's Spliterator
      let generator = {}
      function! generator.yield(times, NONE) abort
        return a:times
      endfunction

      Assert Equals(Stream.generator(generator).limit(5).to_list(), [0,1,2,3,4])
      unlet generator
    End
  End
End
