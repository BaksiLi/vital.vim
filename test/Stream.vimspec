Describe Stream
  Before all
    let Stream = vital#vital#import('Stream')
    let Closure = vital#vital#import('Data.Closure')

    function! Id(n) abort
      return a:n
    endfunction
    function! Succ(n) abort
      return a:n + 1
    endfunction
    function! IsEven(n) abort
      return a:n % 2 == 0
    endfunction
    function! Answer() abort
      return 42
    endfunction
  End

  After all
    delfunction Id
    delfunction Succ
    delfunction Answer
  End

  Describe .has_characteristics()
    It checks if the stream has certain characteristic
      let s = Stream.from_list([], Stream.ORDERED() + Stream.DISTINCT() + Stream.SORTED() + Stream.SIZED() + Stream.IMMUTABLE())
      Assert True(s.has_characteristics(Stream.ORDERED()))
      Assert True(s.has_characteristics(Stream.DISTINCT()))
      Assert True(s.has_characteristics(Stream.SORTED()))
      Assert True(s.has_characteristics(Stream.SIZED()))
      Assert True(s.has_characteristics(Stream.IMMUTABLE()))
    End

    It can check multiple flags at once
      let s = Stream.from_list([], Stream.ORDERED() + Stream.DISTINCT() + Stream.SORTED() + Stream.SIZED() + Stream.IMMUTABLE())
      Assert Equals(
      \ s.has_characteristics([
      \   Stream.ORDERED(),
      \   Stream.DISTINCT(),
      \   Stream.SORTED(),
      \   Stream.SIZED(),
      \   Stream.IMMUTABLE()]),
      \ 1)
      Assert False(Stream.of(1,2,3).has_characteristics([]))
    End
  End

  Describe .of()
    It raises exception for empty arguments
      try
        call Stream.of()
        Assert 0
      catch
        Assert 1
      endtry
    End

    It constructs stream from arguments
      Assert Equals(Stream.of(1).count(), 1)
      Assert Equals(Stream.of(1).to_list(), [1])
      Assert Equals(Stream.of(1,2,3).count(), 3)
      Assert Equals(Stream.of(1,2,3).to_list(), [1,2,3])
    End

    It constructs heterogeneous stream from arguments
      Assert Equals(Stream.of('foo', function('tr'), [], {}, 0.1).count(), 5)
    End

    It creates stream with characteristics
      let s = Stream.of(1,2,3)
      Assert True(s.has_characteristics(Stream.ORDERED()))
      Assert False(s.has_characteristics(Stream.DISTINCT()))
      Assert False(s.has_characteristics(Stream.SORTED()))
      Assert True(s.has_characteristics(Stream.SIZED()))
      Assert True(s.has_characteristics(Stream.IMMUTABLE()))
    End
  End

  Describe .chars()
    It constructs stream of each character from String
      Assert Equals(Stream.chars("").count(), 0)
      Assert Equals(Stream.chars("").to_list(), [])
      Assert Equals(Stream.chars("a").count(), 1)
      Assert Equals(Stream.chars("a").to_list(), ['a'])
      Assert Equals(Stream.chars("abc").count(), 3)
      Assert Equals(Stream.chars("abc").to_list(), ['a', 'b', 'c'])
    End

    It constructs stream of each character from String with characteristics
      let s = Stream.chars("abc", 0)
      Assert False(s.has_characteristics(Stream.ORDERED()))
      Assert False(s.has_characteristics(Stream.DISTINCT()))
      Assert False(s.has_characteristics(Stream.SORTED()))
      Assert False(s.has_characteristics(Stream.SIZED()))
      Assert False(s.has_characteristics(Stream.IMMUTABLE()))
      let s = Stream.chars("abc", Stream.ORDERED() + Stream.DISTINCT() + Stream.SORTED() + Stream.SIZED() + Stream.IMMUTABLE())
      Assert True(s.has_characteristics(Stream.ORDERED()))
      Assert True(s.has_characteristics(Stream.DISTINCT()))
      Assert True(s.has_characteristics(Stream.SORTED()))
      Assert True(s.has_characteristics(Stream.SIZED()))
      Assert True(s.has_characteristics(Stream.IMMUTABLE()))
    End
  End

  Describe .lines()
    It constructs stream of each line from String
      Assert Equals(Stream.lines("").to_list(), [])
      Assert Equals(Stream.lines("foo").to_list(), ['foo'])
      Assert Equals(Stream.lines("foo\nbar").to_list(), ['foo', 'bar'])
      Assert Equals(Stream.lines("foo\n\nbar").to_list(), ['foo', '', 'bar'])
      Assert Equals(Stream.lines("\nfoo\nbar").to_list(), ['', 'foo', 'bar'])
      Assert Equals(Stream.lines("\n\nfoo\nbar").to_list(), ['', '', 'foo', 'bar'])
      Assert Equals(Stream.lines("foo\nbar\n").to_list(), ['foo', 'bar', ''])
      Assert Equals(Stream.lines("foo\nbar\n\n").to_list(), ['foo', 'bar', '', ''])
    End

    It constructs stream of each line from String (\r\n)
      Assert Equals(Stream.lines("").to_list(), [])
      Assert Equals(Stream.lines("foo").to_list(), ['foo'])
      Assert Equals(Stream.lines("foo\r\nbar").to_list(), ['foo', 'bar'])
      Assert Equals(Stream.lines("foo\r\n\r\nbar").to_list(), ['foo', '', 'bar'])
      Assert Equals(Stream.lines("\r\nfoo\r\nbar").to_list(), ['', 'foo', 'bar'])
      Assert Equals(Stream.lines("\r\n\r\nfoo\r\nbar").to_list(), ['', '', 'foo', 'bar'])
      Assert Equals(Stream.lines("foo\r\nbar\r\n").to_list(), ['foo', 'bar', ''])
      Assert Equals(Stream.lines("foo\r\nbar\r\n\r\n").to_list(), ['foo', 'bar', '', ''])
    End

    It constructs stream of each line from String with characteristics
      let s = Stream.lines("abc", 0)
      Assert False(s.has_characteristics(Stream.ORDERED()))
      Assert False(s.has_characteristics(Stream.DISTINCT()))
      Assert False(s.has_characteristics(Stream.SORTED()))
      Assert False(s.has_characteristics(Stream.SIZED()))
      Assert False(s.has_characteristics(Stream.IMMUTABLE()))
      let s = Stream.lines("abc", Stream.ORDERED() + Stream.DISTINCT() + Stream.SORTED() + Stream.SIZED() + Stream.IMMUTABLE())
      Assert True(s.has_characteristics(Stream.ORDERED()))
      Assert True(s.has_characteristics(Stream.DISTINCT()))
      Assert True(s.has_characteristics(Stream.SORTED()))
      Assert True(s.has_characteristics(Stream.SIZED()))
      Assert True(s.has_characteristics(Stream.IMMUTABLE()))
    End
  End

  Describe .from_list()
    It constructs stream from List
      Assert Equals(Stream.from_list([]).count(), 0)
      Assert Equals(Stream.from_list([]).to_list(), [])
      Assert Equals(Stream.from_list([1]).count(), 1)
      Assert Equals(Stream.from_list([1]).to_list(), [1])
      Assert Equals(Stream.from_list([1,2,3]).count(), 3)
      Assert Equals(Stream.from_list([1,2,3]).to_list(), [1,2,3])
    End

    It creates stream with characteristics
      let s = Stream.from_list([1,2,3])
      Assert True(s.has_characteristics(Stream.ORDERED()))
      Assert False(s.has_characteristics(Stream.DISTINCT()))
      Assert False(s.has_characteristics(Stream.SORTED()))
      Assert True(s.has_characteristics(Stream.SIZED()))
      Assert True(s.has_characteristics(Stream.IMMUTABLE()))
    End

    It constructs stream from List with characteristics
      let s = Stream.from_list([1,2,3], 0)
      Assert False(s.has_characteristics(Stream.ORDERED()))
      Assert False(s.has_characteristics(Stream.DISTINCT()))
      Assert False(s.has_characteristics(Stream.SORTED()))
      Assert False(s.has_characteristics(Stream.SIZED()))
      Assert False(s.has_characteristics(Stream.IMMUTABLE()))
      let s = Stream.from_list([1,2,3], Stream.ORDERED() + Stream.DISTINCT() + Stream.SORTED() + Stream.SIZED() + Stream.IMMUTABLE())
      Assert True(s.has_characteristics(Stream.ORDERED()))
      Assert True(s.has_characteristics(Stream.DISTINCT()))
      Assert True(s.has_characteristics(Stream.SORTED()))
      Assert True(s.has_characteristics(Stream.SIZED()))
      Assert True(s.has_characteristics(Stream.IMMUTABLE()))
    End
  End

  Describe .from_dict()
    It constructs stream from Dictionary
      Assert Equals(Stream.from_dict({}).count(), 0)
      Assert Equals(Stream.from_dict({}).to_list(), [])
      Assert Equals(Stream.from_dict({"foo": 1}).count(), 1)
      Assert Equals(Stream.from_dict({"foo": 1}).to_list(), [["foo", 1]])
      Assert Equals(Stream.from_dict(
      \ {"foo": 1, "bar": 3, "baz": 2}).count(),
      \ 3)
      Assert Equals(
      \ sort(Stream.from_dict({"foo": 1, "bar": 3, "baz": 2}).to_list()),
      \ [["bar", 3], ["baz", 2], ["foo", 1]])
    End

    It constructs heterogeneous stream from Dictionary
      Assert Equals(Stream.from_dict(
      \ {"foo": 42, "bar": 3.14, "baz": function('tr')}).count(),
      \ 3)
      Assert Equals(
      \ sort(Stream.from_dict(
      \ {"foo": 42, "bar": 3.14, "baz": function('tr')}).to_list()),
      \ [['bar', 3.14], ['baz', function('tr')], ['foo', 42]])
    End

    It creates stream with characteristics
      let s = Stream.from_dict({"foo": 1, "bar": 3, "baz": 2})
      Assert False(s.has_characteristics(Stream.ORDERED()))
      Assert True(s.has_characteristics(Stream.DISTINCT()))
      Assert False(s.has_characteristics(Stream.SORTED()))
      Assert True(s.has_characteristics(Stream.SIZED()))
      Assert True(s.has_characteristics(Stream.IMMUTABLE()))
    End

    It constructs stream from Dictionary with characteristics
      let s = Stream.from_list({"foo": 1}, 0)
      Assert False(s.has_characteristics(Stream.ORDERED()))
      Assert False(s.has_characteristics(Stream.DISTINCT()))
      Assert False(s.has_characteristics(Stream.SORTED()))
      Assert False(s.has_characteristics(Stream.SIZED()))
      Assert False(s.has_characteristics(Stream.IMMUTABLE()))
      let s = Stream.from_list({"foo": 1}, Stream.ORDERED() + Stream.DISTINCT() + Stream.SORTED() + Stream.SIZED() + Stream.IMMUTABLE())
      Assert True(s.has_characteristics(Stream.ORDERED()))
      Assert True(s.has_characteristics(Stream.DISTINCT()))
      Assert True(s.has_characteristics(Stream.SORTED()))
      Assert True(s.has_characteristics(Stream.SIZED()))
      Assert True(s.has_characteristics(Stream.IMMUTABLE()))
    End
  End

  Describe .empty()
    It constructs empty stream
      Assert Equals(Stream.empty().count(), 0)
      Assert Equals(Stream.empty().to_list(), [])
    End

    It creates stream with characteristics
      let s = Stream.empty()
      Assert True(s.has_characteristics(Stream.ORDERED()))
      Assert False(s.has_characteristics(Stream.DISTINCT()))
      Assert False(s.has_characteristics(Stream.SORTED()))
      Assert True(s.has_characteristics(Stream.SIZED()))
      Assert True(s.has_characteristics(Stream.IMMUTABLE()))
    End
  End

  Describe .range()
    It throws an exception for invalid arguments
      try
        call Stream.range(-2, 2, 0)
        Assert 0
      catch /vital: Stream: range(): stride is 0/
        Assert 1
      endtry
    End

    It constructs stream from range
      Assert Equals(
      \   Stream.range(-2, 2).to_list(),
      \   [-2,-1,0,1,2])

      Assert Equals(
      \   Stream.range(10, 3).to_list(),
      \   [])
      Assert Equals(
      \   Stream.range(1, 0).to_list(),
      \   [])
      Assert Equals(
      \   Stream.range(1, 1).to_list(),
      \   [1])
      Assert Equals(
      \   Stream.range(1, 2).to_list(),
      \   [1,2])
      Assert Equals(
      \   Stream.range(1, 4).to_list(),
      \   [1,2,3,4])
    End

    It can omit 2nd or 3rd argument
      Assert Equals(
      \   Stream.range(-2, 2, 2).to_list(),
      \   [-2,0,2])

      Assert Equals(
      \   Stream.range(3).to_list(),
      \   [0,1,2])
      Assert Equals(
      \   Stream.range(1).to_list(),
      \   [0])
      Assert Equals(
      \   Stream.range(0).to_list(),
      \   [])
      Assert Equals(
      \   Stream.range(-1).to_list(),
      \   [])
      Assert Equals(
      \   Stream.range(-2).to_list(),
      \   [])

      Assert Equals(
      \   Stream.range(0, 10, 2).to_list(),
      \   [0,2,4,6,8,10])
      Assert Equals(
      \   Stream.range(0, 9, 2).to_list(),
      \   [0,2,4,6,8])
      Assert Equals(
      \   Stream.range(0, 9, 3).to_list(),
      \   [0,3,6,9])
      Assert Equals(
      \   Stream.range(0, 8, 3).to_list(),
      \   [0,3,6])
    End

    It constructs limited range when .limit() was specified
      Assert Equals(
      \   Stream.range(1, 1/0).limit(5).to_list(),
      \   [1,2,3,4,5])
      Assert Equals(
      \   Stream.range(5, 1/0).limit(5).to_list(),
      \   [5,6,7,8,9])
    End

    It creates stream with characteristics
      let s = Stream.range(1,10)
      Assert True(s.has_characteristics(Stream.ORDERED()))
      Assert True(s.has_characteristics(Stream.DISTINCT()))
      Assert True(s.has_characteristics(Stream.SORTED()))
      Assert True(s.has_characteristics(Stream.SIZED()))
      Assert True(s.has_characteristics(Stream.IMMUTABLE()))
    End
  End

  Describe .iterate()
    It constructs infinite stream with initial value and function
      Assert Equals(
      \   Stream.iterate(1, 'v:val').limit(3).to_list(),
      \   [1,1,1])
      Assert Equals(
      \   Stream.iterate(5, 'v:val + 1').limit(3).to_list(),
      \   [5,6,7])
    End

    It constructs infinite stream by funcref
      Assert Equals(
      \   Stream.iterate(1, function('Id')).limit(3).to_list(),
      \   [1,1,1])
      Assert Equals(
      \   Stream.iterate(5, function('Succ')).limit(3).to_list(),
      \   [5,6,7])
    End

    It constructs infinite stream by Data.Closure
      Assert Equals(
      \   Stream.iterate(1, Closure.from_expr('a:1')).limit(3).to_list(),
      \   [1,1,1])
      Assert Equals(
      \   Stream.iterate(5, Closure.from_expr('a:1 + 1')).limit(3).to_list(),
      \   [5,6,7])
    End

    It creates stream with characteristics
      let s = Stream.iterate(1, 'v:val + 1')
      Assert True(s.has_characteristics(Stream.ORDERED()))
      Assert False(s.has_characteristics(Stream.DISTINCT()))
      Assert False(s.has_characteristics(Stream.SORTED()))
      Assert False(s.has_characteristics(Stream.SIZED()))
      Assert True(s.has_characteristics(Stream.IMMUTABLE()))
    End
  End

  Describe .generate()
    It constructs infinite stream
      Assert Equals(
      \ Stream.generate('42').limit(5).to_list(),
      \ [42, 42, 42, 42, 42])
    End

    It constructs infinite stream by funcref
      Assert Equals(
      \ Stream.generate(function('Answer')).limit(5).to_list(),
      \ [42, 42, 42, 42, 42])
    End

    It constructs infinite stream by Data.Closure
      Assert Equals(
      \ Stream.generate(Closure.from_expr('42')).limit(5).to_list(),
      \ [42, 42, 42, 42, 42])
    End
  End

  Describe .zip()
    It combines zipped stream
      Assert Equals(
        \Stream.zip(
          \Stream.empty(),
          \Stream.empty())
        \.to_list(),
        \[])

      Assert Equals(
        \Stream.zip(
          \Stream.empty(),
          \Stream.of(1))
        \.to_list(),
        \[])

      Assert Equals(
        \Stream.zip(
          \Stream.of(1,2,3),
          \Stream.of(4,5,6))
        \.to_list(),
        \[[1,4], [2,5], [3,6]])

      Assert Equals(
        \Stream.zip(
          \Stream.of(1,2),
          \Stream.of(4,5,6))
        \.to_list(),
        \[[1,4], [2,5]])

      Assert Equals(
        \Stream.zip(
          \Stream.of(1,2,3),
          \Stream.of(4,5))
        \.to_list(),
        \[[1,4], [2,5]])

      Assert Equals(
        \Stream.zip(
          \Stream.of(1),
          \Stream.empty())
        \.to_list(),
        \[])

      Assert Equals(
        \Stream.zip(
          \Stream.empty(),
          \Stream.of(1))
        \.to_list(),
        \[])

      Assert Equals(
        \Stream.zip(
          \Stream.iterate(1, 'v:val + 1'),
          \Stream.of(5, 4, 3, 2, 1))
        \.to_list(),
        \[[1,5], [2,4], [3,3], [4,2], [5,1]])

      Assert Equals(
        \Stream.zip(
          \Stream.iterate(1, 'v:val + 1'),
          \Stream.iterate(-1, 'v:val - 1'))
        \.limit(5).to_list(),
        \[[1,-1], [2,-2], [3,-3], [4,-4], [5,-5]])
    End

    It combines zipped stream (method version)
      Assert Equals(
        \Stream.of(1,2,3).zip(Stream.of(4,5,6)).to_list(),
        \[[1,4], [2,5], [3,6]])
    End

    It combines stream from String with characteristics
      " Use or() for SIZED flag. Use and() for other flags
      let s = Stream.zip(Stream.of(1,2,3), Stream.of(4,5,6))
      Assert True(s.has_characteristics(Stream.ORDERED()))
      Assert False(s.has_characteristics(Stream.DISTINCT()))
      Assert False(s.has_characteristics(Stream.SORTED()))
      Assert True(s.has_characteristics(Stream.SIZED()))
      Assert True(s.has_characteristics(Stream.IMMUTABLE()))
      let s = Stream.zip(Stream.iterate(0, 'v:val + 1'), Stream.of(1,2,3))
      Assert True(s.has_characteristics(Stream.ORDERED()))
      Assert False(s.has_characteristics(Stream.DISTINCT()))
      Assert False(s.has_characteristics(Stream.SORTED()))
      Assert True(s.has_characteristics(Stream.SIZED()))
      Assert True(s.has_characteristics(Stream.IMMUTABLE()))
    End

    It combines stream with 3 or more than streams
      Assert Equals(
          \Stream.zip(Stream.of(1,2,3), Stream.of(4,5,6), Stream.of(7,8,9))
                \.to_list(),
          \[[1,4,7], [2,5,8], [3,6,9]])

      Assert Equals(
          \Stream.of(1,2,3).zip(Stream.of(4,5,6), Stream.of(7,8,9))
                \.to_list(),
          \[[1,4,7], [2,5,8], [3,6,9]])

      Assert Equals(
          \Stream.zip(Stream.of(1), Stream.of(4,5,6), Stream.of(7,8,9))
                \.to_list(),
          \[[1,4,7]])

      Assert Equals(
          \Stream.of(1).zip(Stream.of(4,5,6), Stream.of(7,8,9))
                \.to_list(),
          \[[1,4,7]])

      Assert Equals(
          \Stream.zip(
              \Stream.iterate(1, 'v:val + 1'),
              \Stream.of(4,5,6),
              \Stream.of(7,8,9)).to_list(),
          \[[1,4,7], [2,5,8], [3,6,9]])

      Assert Equals(
          \Stream.iterate(1, 'v:val + 1').zip(
              \Stream.of(4,5,6),
              \Stream.of(7,8,9)).to_list(),
          \[[1,4,7], [2,5,8], [3,6,9]])
    End

    It combines stream with 3 or more than streams with characteristics
      " Use or() for SIZED flag. Use and() for other flags
      let s = Stream.zip(Stream.of(1,2,3), Stream.of(4,5,6), Stream.of(7,8,9))
      Assert True(s.has_characteristics(Stream.ORDERED()))
      Assert False(s.has_characteristics(Stream.DISTINCT()))
      Assert False(s.has_characteristics(Stream.SORTED()))
      Assert True(s.has_characteristics(Stream.SIZED()))
      Assert True(s.has_characteristics(Stream.IMMUTABLE()))
      let s = Stream.zip(Stream.iterate(0, 'v:val + 1'), Stream.of(1,2,3), Stream.of(4,5,6))
      Assert True(s.has_characteristics(Stream.ORDERED()))
      Assert False(s.has_characteristics(Stream.DISTINCT()))
      Assert False(s.has_characteristics(Stream.SORTED()))
      Assert True(s.has_characteristics(Stream.SIZED()))
      Assert True(s.has_characteristics(Stream.IMMUTABLE()))
    End
  End

  Describe .zip_with_index()
    It combines infinite stream with function
      Assert Equals(
      \ Stream.empty().zip_with_index().to_list(),
      \ [])

      Assert Equals(
      \ Stream.of(4,5,6).zip_with_index().to_list(),
      \ [[0,4], [1,5], [2,6]])
    End
  End

  Describe .concat()
    It concatenates stream
      Assert Equals(
        \Stream.concat(
          \Stream.of(1,2,3),
          \Stream.of(4,5))
        \.to_list(),
        \[1,2,3,4,5])

      Assert Equals(
        \Stream.concat(
          \Stream.of(1,2,3),
          \Stream.empty())
        \.to_list(),
        \[1,2,3])

      Assert Equals(
        \Stream.concat(
          \Stream.empty(),
          \Stream.of(4,5))
        \.to_list(),
        \[4,5])

      Assert Equals(
        \Stream.concat(
          \Stream.iterate(1, 'v:val + 1'),
          \Stream.of('this stream cannot be merged...'))
        \.limit(5).to_list(),
        \[1,2,3,4,5])

      Assert Equals(
        \Stream.concat(
          \Stream.of(1,2,3),
          \Stream.iterate(4, 'v:val + 1'))
        \.limit(5).to_list(),
        \[1,2,3,4,5])
    End

    It concatenates stream from 3 or more than streams
      Assert Equals(
        \Stream.concat(
          \Stream.of(1),
          \Stream.of(2),
          \Stream.of(3))
        \.to_list(),
        \[1,2,3])

      Assert Equals(
        \Stream.concat(
          \Stream.of(1),
          \Stream.of(2),
          \Stream.empty(),
          \Stream.of(3))
        \.to_list(),
        \[1,2,3])
    End

    It concatenates stream from 3 or more than streams (method version)
      Assert Equals(
        \Stream.of(1).concat(Stream.of(2), Stream.of(3)).to_list(),
        \[1,2,3])

      Assert Equals(
        \Stream.of(1).concat(Stream.of(2), Stream.empty(), Stream.of(3)).to_list(),
        \[1,2,3])
    End

    It concatenates infinite stream with function (method version)
      Assert Equals(
        \Stream.of(1,2,3).concat(Stream.of(4,5)).to_list(),
        \[1,2,3,4,5])
    End
  End

  Describe .limit()
    It raises negative number argument
      try
        call Stream.of(1,2,3,4,5).limit(-1)
        Assert 0
      catch /vital: Stream: limit(n): n must be 0 or positive/
        Assert 1
      endtry
      try
        call Stream.of(1,2,3,4,5).limit(0)
        Assert 1
      catch /vital: Stream: limit(n): n must be 0 or positive/
        Assert 0
      endtry
    End

    It limits stream
      Assert Equals(Stream.of(1,2,3,4,5).limit(0).to_list(), [])
      Assert Equals(Stream.of(1,2,3,4,5).limit(3).to_list(), [1,2,3])
      Assert Equals(Stream.of(3,4,5,6,7).limit(3).to_list(), [3,4,5])
      Assert Equals(Stream.iterate(1, 'v:val + 1').limit(3).to_list(), [1,2,3])
    End

    It sets SIZED characteristic
      let s = Stream.of(3,4,5,6,7).limit(3)
      Assert True(s.has_characteristics(Stream.ORDERED()))
      Assert False(s.has_characteristics(Stream.DISTINCT()))
      Assert False(s.has_characteristics(Stream.SORTED()))
      Assert True(s.has_characteristics(Stream.SIZED()))
      Assert True(s.has_characteristics(Stream.IMMUTABLE()))
      let s = Stream.iterate(1, 'v:val + 1').limit(3)
      Assert True(s.has_characteristics(Stream.ORDERED()))
      Assert False(s.has_characteristics(Stream.DISTINCT()))
      Assert False(s.has_characteristics(Stream.SORTED()))
      Assert True(s.has_characteristics(Stream.SIZED()))
      Assert True(s.has_characteristics(Stream.IMMUTABLE()))
    End

    It must not reuse stream
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.limit(3)
        Assert 1
      catch
        Assert 0
      endtry
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.limit(3).to_list()
        Assert 0
      catch
        Assert 1
      endtry
    End
  End

  Describe .skip()
    It raises negative number argument
      try
        call Stream.of(1,2,3,4,5).skip(-1)
        Assert 0
      catch /vital: Stream: skip(n): n must be 0 or positive/
        Assert 1
      endtry
      try
        call Stream.of(1,2,3,4,5).skip(0)
        Assert 1
      catch /vital: Stream: skip(n): n must be 0 or positive/
        Assert 0
      endtry
    End

    It limits stream
      Assert Equals(Stream.of(1,2,3,4,5).skip(0).to_list(), [1,2,3,4,5])
      Assert Equals(Stream.of(1,2,3,4,5).skip(3).to_list(), [4,5])
      Assert Equals(Stream.of(3,4,5,6,7).skip(3).to_list(), [6,7])
      Assert Equals(Stream.iterate(1, 'v:val + 1').skip(3).limit(3).to_list(), [4,5,6])
    End

    It must not reuse stream
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.skip(3)
        Assert 1
      catch
        Assert 0
      endtry
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.skip(3).to_list()
        Assert 0
      catch
        Assert 1
      endtry
    End
  End

  Describe .peek()
    It peeks stream
      let g:peek = []
      Assert Equals(Stream.of(1,2,3).peek('add(g:peek, v:val)').to_list(), [1,2,3])
      Assert Equals(g:peek, [1,2,3])
      unlet g:peek
    End

    It does not peek anything for empty stream
      let g:peek = []
      Assert Equals(Stream.empty().peek('add(g:peek, v:val)').to_list(), [])
      Assert Equals(g:peek, [])
      unlet g:peek
    End

    It peeks stream by funcref
      let g:peek = []
      function! Add(v) abort
        let g:peek += [a:v]
      endfunction
      Assert Equals(Stream.of(1,2,3).peek(function('Add')).to_list(), [1,2,3])
      Assert Equals(g:peek, [1,2,3])
      unlet g:peek
      delfunction Add
    End

    It peeks stream by Data.Closure
      let g:peek = []
      Assert Equals(Stream.of(1,2,3).peek(Closure.from_command('let g:peek += [a:1]')).to_list(), [1,2,3])
      Assert Equals(g:peek, [1,2,3])
      unlet g:peek
    End

    It must not reuse stream
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.peek('v:val')
        Assert 1
      catch
        Assert 0
      endtry
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.peek('v:val').to_list()
        Assert 0
      catch
        Assert 1
      endtry
    End
  End

  Describe .foreach()
    It iterates elements in stream
      let g:foreach = []
      Assert Equals(Stream.of(1,2,3).foreach('add(g:foreach, v:val)'), 0)
      Assert Equals(g:foreach, [1,2,3])
      unlet g:foreach
    End

    It peeks stream by funcref
      let g:foreach = []
      function! Add(v) abort
        let g:foreach += [a:v]
      endfunction
      Assert Equals(Stream.of(1,2,3).foreach(function('Add')), 0)
      Assert Equals(g:foreach, [1,2,3])
      unlet g:foreach
      delfunction Add
    End

    It peeks stream by Data.Closure
      let g:foreach = []
      Assert Equals(Stream.of(1,2,3).foreach(Closure.from_command('let g:foreach += [a:1]')), 0)
      Assert Equals(g:foreach, [1,2,3])
      unlet g:foreach
    End

    It must not reuse stream
      try
        let s = Stream.of(1,2,3,4,5)
        call s.foreach('v:val')
        Assert 1
      catch
        Assert 0
      endtry
      try
        let s = Stream.of(1,2,3,4,5)
        call s.foreach('v:val')
        call s.foreach('v:val')
        Assert 0
      catch
        Assert 1
      endtry
    End
  End

  Describe .map()
    It maps stream
      Assert Equals(Stream.empty().map('v:val + 1').to_list(), [])

      Assert Equals(
      \ Stream.iterate(1, 'v:val + 1').map('v:val + 1').limit(3).to_list(),
      \ [2,3,4])
    End

    It maps stream by funcref
      Assert Equals(Stream.empty().map(function('Succ')).to_list(), [])

      Assert Equals(
      \ Stream.iterate(1, 'v:val + 1').map(function('Succ')).limit(3).to_list(),
      \ [2,3,4])
    End

    It maps stream by Data.Closure
      Assert Equals(Stream.empty().map(Closure.from_expr('a:1 + 1')).to_list(), [])

      Assert Equals(
      \ Stream.iterate(1, 'v:val + 1').map(Closure.from_expr('a:1 + 1')).limit(3).to_list(),
      \ [2,3,4])
    End

    It must not reuse stream
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.map('v:val')
        Assert 1
      catch
        Assert 0
      endtry
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.map('v:val').to_list()
        Assert 0
      catch
        Assert 1
      endtry
    End
  End

  Describe .flatmap()
    It flattens mapped stream
      Assert Equals(Stream.empty().flatmap('[v:val]').to_list(), [])

      Assert Equals(
        \Stream.iterate(0, 'v:val + 1')
          \.flatmap('repeat([v:val], v:val)').limit(6).to_list(),
        \[1,2,2,3,3,3])

      Assert Equals(
        \Stream.of(1,2,3)
          \.flatmap('repeat([v:val], v:val)').to_list(),
        \[1,2,2,3,3,3])

      Assert Equals(
        \Stream.of(1,2,3)
          \.flatmap('repeat([v:val], v:val)').limit(6).to_list(),
        \[1,2,2,3,3,3])

      Assert Equals(
        \Stream.of(1,2,3,4,5)
          \.flatmap('repeat([v:val], v:val)').limit(6).to_list(),
        \[1,2,2,3,3,3])

      Assert Equals(
        \Stream.of(0,1,2,3,4,5)
          \.flatmap('v:val % 2 == 0 ? [v:val * 2] : []').limit(3).to_list(),
        \[0, 4, 8])

      Assert Equals(
        \Stream.iterate(0, 'v:val + 1')
          \.flatmap('v:val % 2 == 0 ? [v:val * 2] : []').limit(3).to_list(),
        \[0, 4, 8])
    End

    It flattens mapped stream by funcref
      function! Repeat(n) abort
        return repeat([a:n], a:n)
      endfunction

      Assert Equals(Stream.empty().flatmap(function('Repeat')).to_list(), [])

      Assert Equals(
        \Stream.iterate(0, function('Succ'))
          \.flatmap(function('Repeat')).limit(6).to_list(),
        \[1,2,2,3,3,3])

      delfunction Repeat
    End

    It flattens mapped stream by Data.Closure
      Assert Equals(Stream.empty().flatmap(Closure.from_expr('repeat([a:1], a:1)')).to_list(), [])

      Assert Equals(
        \Stream.iterate(0, Closure.from_expr('a:1 + 1'))
          \.flatmap(Closure.from_expr('repeat([a:1], a:1)')).limit(6).to_list(),
        \[1,2,2,3,3,3])
    End

    It must not reuse stream
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.flatmap('v:val')
        Assert 1
      catch
        Assert 0
      endtry
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.flatmap('v:val').to_list()
        Assert 0
      catch
        Assert 1
      endtry
    End
  End

  Describe .slice_before()
    It maps stream
      let is_even = 'v:val % 2 == 0'
      let is_multiple_of_3 = 'v:val % 3 == 0'

      " empty stream
      Assert Equals(Stream.empty().slice_before(is_even).to_list(), [])

      " finite stream (is_even)
      Assert Equals(
      \ Stream.of(0,1,2,3,4,5).slice_before(is_even).to_list(),
      \ [[0,1], [2,3], [4,5]])

      Assert Equals(
      \ Stream.of(1,2,3,4,5).slice_before(is_even).to_list(),
      \ [[1], [2,3], [4,5]])

      Assert Equals(
      \ Stream.of(0,1,2,3,4).slice_before(is_even).to_list(),
      \ [[0,1], [2,3], [4]])

      Assert Equals(
      \ Stream.of(1,2,3,4).slice_before(is_even).to_list(),
      \ [[1], [2,3], [4]])

      " finite stream (is_multiple_of_3)
      Assert Equals(
      \ Stream.of(0,1,2,3,4,5).slice_before(is_multiple_of_3).to_list(),
      \ [[0,1,2], [3,4,5]])

      Assert Equals(
      \ Stream.of(1,2,3,4,5).slice_before(is_multiple_of_3).to_list(),
      \ [[1,2], [3,4,5]])

      Assert Equals(
      \ Stream.of(0,1,2,3,4).slice_before(is_multiple_of_3).to_list(),
      \ [[0,1,2], [3,4]])

      Assert Equals(
      \ Stream.of(1,2,3,4).slice_before(is_multiple_of_3).to_list(),
      \ [[1,2], [3,4]])

      " inifinite stream
      Assert Equals(
      \ Stream.iterate(1, 'v:val + 1').slice_before(is_even).limit(3).to_list(),
      \ [[1], [2,3], [4,5]])

      Assert Equals(
      \ Stream.iterate(0, 'v:val + 1').slice_before(is_even).limit(3).to_list(),
      \ [[0,1], [2,3], [4,5]])

      Assert Equals(
      \ Stream.iterate(1, 'v:val + 1').slice_before(is_even).limit(3).to_list(),
      \ [[1], [2,3], [4,5]])
    End

    It must not reuse stream
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.slice_before('v:val')
        Assert 1
      catch
        Assert 0
      endtry
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.slice_before('v:val').to_list()
        Assert 0
      catch
        Assert 1
      endtry
    End
  End

  Describe .filter()
    It filters stream
      Assert Equals(Stream.empty().filter('v:val % 2 == 0').to_list(), [])

      Assert Equals(
      \ Stream.iterate(0, 'v:val + 1').filter('v:val % 2 == 0').limit(3).to_list(),
      \ [0,2,4])
    End

    It filters stream by funcref
      Assert Equals(Stream.empty().filter(function('IsEven')).to_list(), [])

      Assert Equals(
      \ Stream.iterate(0, 'v:val + 1').filter(function('IsEven')).limit(3).to_list(),
      \ [0,2,4])
    End

    It filters stream by Data.Closure
      Assert Equals(Stream.empty().filter(Closure.from_expr('a:1 % 2 == 0')).to_list(), [])

      Assert Equals(
      \ Stream.iterate(0, 'v:val + 1').filter(Closure.from_expr('a:1 % 2 == 0')).limit(3).to_list(),
      \ [0,2,4])
    End

    It must not reuse stream
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.filter('v:val % 2 == 0')
        Assert 1
      catch
        Assert 0
      endtry
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.filter('v:val % 2 == 0').to_list()
        Assert 0
      catch
        Assert 1
      endtry
    End
  End

  Describe .take_while()
    It takes elements until element is matched
      Assert Equals(Stream.empty().take_while('v:val < 4').to_list(), [])
      Assert Equals(
      \ Stream.range(1, 10).take_while('v:val < 4').to_list(),
      \ [1,2,3])
      Assert Equals(
      \ Stream.range(1, 10).take_while('v:val < 4').limit(2).to_list(),
      \ [1,2])
      Assert Equals(
      \ Stream.iterate(1, 'v:val + 1').take_while('v:val < 4').to_list(),
      \ [1,2,3])
    End

    It takes elements until element is matched by funcref
      function! LessThan4(n) abort
        return a:n < 4
      endfunction

      Assert Equals(Stream.empty().take_while(function('LessThan4')).to_list(), [])
      Assert Equals(
      \ Stream.range(1, 10).take_while(function('LessThan4')).to_list(),
      \ [1,2,3])
      Assert Equals(
      \ Stream.range(1, 10).take_while(function('LessThan4')).limit(2).to_list(),
      \ [1,2])
      Assert Equals(
      \ Stream.iterate(1, function('Succ')).take_while(function('LessThan4')).to_list(),
      \ [1,2,3])

      delfunction LessThan4
    End

    It takes elements until element is matched by Data.Closure
      Assert Equals(Stream.empty().take_while(Closure.from_expr('a:1 < 4')).to_list(), [])
      Assert Equals(
      \ Stream.range(1, 10).take_while(Closure.from_expr('a:1 < 4')).to_list(),
      \ [1,2,3])
      Assert Equals(
      \ Stream.range(1, 10).take_while(Closure.from_expr('a:1 < 4')).limit(2).to_list(),
      \ [1,2])
      Assert Equals(
      \ Stream.iterate(1, Closure.from_expr('a:1 + 1')).take_while(Closure.from_expr('a:1 < 4')).to_list(),
      \ [1,2,3])
    End

    It must not reuse stream
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.take_while('v:val')
        Assert 1
      catch
        Assert 0
      endtry
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.take_while('v:val').to_list()
        Assert 0
      catch
        Assert 1
      endtry
    End
  End

  Describe .drop_while()
    It drops elements until element is matched
      Assert Equals(
      \ Stream.empty().drop_while('v:val < 4').to_list(),
      \ [])
      Assert Equals(
      \ Stream.of(1,2,3,4,5).drop_while('v:val < 4').to_list(),
      \ [4,5])
      Assert Equals(
      \ Stream.iterate(1, 'v:val + 1').drop_while('v:val < 4').limit(2).to_list(),
      \ [4,5])
    End

    It drops elements until element is matched by funcref
      function! LessThan4(n) abort
        return a:n < 4
      endfunction

      Assert Equals(
      \ Stream.empty().drop_while(function('LessThan4')).to_list(),
      \ [])
      Assert Equals(
      \ Stream.of(1,2,3,4,5).drop_while(function('LessThan4')).to_list(),
      \ [4,5])
      Assert Equals(
      \ Stream.iterate(1, function('Succ')).drop_while(function('LessThan4')).limit(2).to_list(),
      \ [4,5])

      delfunction LessThan4
    End

    It drops elements until element is matched by Data.Closure
      Assert Equals(
      \ Stream.empty().drop_while(Closure.from_expr('a:1 < 4')).to_list(),
      \ [])
      Assert Equals(
      \ Stream.of(1,2,3,4,5).drop_while(Closure.from_expr('a:1 < 4')).to_list(),
      \ [4,5])
      Assert Equals(
      \ Stream.iterate(1, Closure.from_expr('a:1 + 1')).drop_while(Closure.from_expr('a:1 < 4')).limit(2).to_list(),
      \ [4,5])
    End

    It must not reuse stream
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.drop_while('v:val')
        Assert 1
      catch
        Assert 0
      endtry
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.drop_while('v:val').to_list()
        Assert 0
      catch
        Assert 1
      endtry
    End
  End

  Describe .distinct()
    It dedupes elements in stream
      Assert Equals(Stream.empty().distinct().to_list(), [])
      Assert Equals(Stream.of(1,2,3).distinct().to_list(), [1,2,3])
      Assert Equals(Stream.of(1,1,2,2,3).distinct().to_list(), [1,2,3])
      Assert Equals(Stream.of(1,2,3,2,3).distinct().to_list(), [1,2,3])
      Assert Equals(Stream.of(3,1,2).distinct().to_list(), [3,1,2])
      Assert Equals(Stream.of(3,3,1,1,2).distinct().to_list(), [3,1,2])
      Assert Equals(Stream.of(3,1,2,1,2).distinct().to_list(), [3,1,2])
      Assert Equals(
      \ Stream.iterate(0, '(v:val + 1) % 3').distinct().limit(3).to_list(),
      \ [0,1,2])
    End

    It dedupes elements in stream with stringifier
      Assert Equals(Stream.empty().distinct('v:val.value').to_list(), [])
      Assert Equals(
        \Stream.of({'value': 1}, {'value': 2}, {'value': 3}).distinct('v:val.value').to_list(),
        \[{'value': 1}, {'value': 2}, {'value': 3}])
      Assert Equals(
        \Stream.of({'value': 1}, {'value': 1}, {'value': 2}, {'value': 2}, {'value': 3}).distinct('v:val.value').to_list(),
        \[{'value': 1}, {'value': 2}, {'value': 3}])
      Assert Equals(
        \Stream.of({'value': 1}, {'value': 2}, {'value': 3}, {'value': 2}, {'value': 3}).distinct('v:val.value').to_list(),
        \[{'value': 1}, {'value': 2}, {'value': 3}])
      Assert Equals(
        \Stream.of({'value': 3}, {'value': 1}, {'value': 2}).distinct('v:val.value').to_list(),
        \[{'value': 3}, {'value': 1}, {'value': 2}])
      Assert Equals(
        \Stream.of({'value': 3}, {'value': 3}, {'value': 1}, {'value': 1}, {'value': 2}).distinct('v:val.value').to_list(),
        \[{'value': 3}, {'value': 1}, {'value': 2}])
      Assert Equals(
        \Stream.of({'value': 3}, {'value': 1}, {'value': 2}, {'value': 1}, {'value': 2}).distinct('v:val.value').to_list(),
        \[{'value': 3}, {'value': 1}, {'value': 2}])
    End

    It dedupes elements in stream with stringifier by funcref
      function! ValueOf(v) abort
        return a:v.value
      endfunction

      Assert Equals(Stream.empty().distinct(function('ValueOf')).to_list(), [])
      Assert Equals(
        \Stream.of({'value': 1}, {'value': 2}, {'value': 3}).distinct(function('ValueOf')).to_list(),
        \[{'value': 1}, {'value': 2}, {'value': 3}])
      Assert Equals(
        \Stream.of({'value': 1}, {'value': 1}, {'value': 2}, {'value': 2}, {'value': 3}).distinct(function('ValueOf')).to_list(),
        \[{'value': 1}, {'value': 2}, {'value': 3}])
      Assert Equals(
        \Stream.of({'value': 1}, {'value': 2}, {'value': 3}, {'value': 2}, {'value': 3}).distinct(function('ValueOf')).to_list(),
        \[{'value': 1}, {'value': 2}, {'value': 3}])
      Assert Equals(
        \Stream.of({'value': 3}, {'value': 1}, {'value': 2}).distinct(function('ValueOf')).to_list(),
        \[{'value': 3}, {'value': 1}, {'value': 2}])
      Assert Equals(
        \Stream.of({'value': 3}, {'value': 3}, {'value': 1}, {'value': 1}, {'value': 2}).distinct(function('ValueOf')).to_list(),
        \[{'value': 3}, {'value': 1}, {'value': 2}])
      Assert Equals(
        \Stream.of({'value': 3}, {'value': 1}, {'value': 2}, {'value': 1}, {'value': 2}).distinct(function('ValueOf')).to_list(),
        \[{'value': 3}, {'value': 1}, {'value': 2}])

      delfunction ValueOf
    End

    It dedupes elements in stream with stringifier by Data.Closure
      let value_of = Closure.from_expr('a:1.value')

      Assert Equals(Stream.empty().distinct(value_of).to_list(), [])
      Assert Equals(
        \Stream.of({'value': 1}, {'value': 2}, {'value': 3}).distinct(value_of).to_list(),
        \[{'value': 1}, {'value': 2}, {'value': 3}])
      Assert Equals(
        \Stream.of({'value': 1}, {'value': 1}, {'value': 2}, {'value': 2}, {'value': 3}).distinct(value_of).to_list(),
        \[{'value': 1}, {'value': 2}, {'value': 3}])
      Assert Equals(
        \Stream.of({'value': 1}, {'value': 2}, {'value': 3}, {'value': 2}, {'value': 3}).distinct(value_of).to_list(),
        \[{'value': 1}, {'value': 2}, {'value': 3}])
      Assert Equals(
        \Stream.of({'value': 3}, {'value': 1}, {'value': 2}).distinct(value_of).to_list(),
        \[{'value': 3}, {'value': 1}, {'value': 2}])
      Assert Equals(
        \Stream.of({'value': 3}, {'value': 3}, {'value': 1}, {'value': 1}, {'value': 2}).distinct(value_of).to_list(),
        \[{'value': 3}, {'value': 1}, {'value': 2}])
      Assert Equals(
        \Stream.of({'value': 3}, {'value': 1}, {'value': 2}, {'value': 1}, {'value': 2}).distinct(value_of).to_list(),
        \[{'value': 3}, {'value': 1}, {'value': 2}])
    End
  End

  Describe .sorted()
    It sorts elements in stream without comparator
      Assert Equals(Stream.empty().sorted().to_list(), [])
      Assert Equals(Stream.of(2,1,3).sorted().to_list(), [1,2,3])
      Assert Equals(Stream.of(2,1,3,2,1).sorted().to_list(), [1,1,2,2,3])
      Assert Equals(
      \ Stream.iterate(3, 'v:val - 1').limit(3).sorted().to_list(),
      \ [1,2,3])
      Assert Equals(Stream.of(4,5,6,1,2,3).sorted().limit(3).to_list(), [1,2,3])
    End

    It sorts elements in stream with comparator
      let by_desc = 'v:val[0] > v:val[1] ? -1 : v:val[0] ==# v:val[1] ? 0 : 1'
      Assert Equals(Stream.empty().sorted(by_desc).to_list(), [])
      Assert Equals(Stream.of(2,1,3).sorted(by_desc).to_list(), [3,2,1])
      Assert Equals(Stream.of(2,1,3,2,1).sorted(by_desc).to_list(), [3,2,2,1,1])
      Assert Equals(
      \ Stream.iterate(1, 'v:val + 1').limit(3).sorted(by_desc).to_list(),
      \ [3,2,1])
    End

    It sorts elements in stream with comparator by funcref
      function! Compare(a, b) abort
        return a:a > a:b ? -1 : a:a ==# a:b ? 0 : 1
      endfunction

      Assert Equals(Stream.empty().sorted(function('Compare')).to_list(), [])
      Assert Equals(Stream.of(2,1,3).sorted(function('Compare')).to_list(), [3,2,1])
      Assert Equals(Stream.of(2,1,3,2,1).sorted(function('Compare')).to_list(), [3,2,2,1,1])
      Assert Equals(
      \ Stream.iterate(1, 'v:val + 1').limit(3).sorted(function('Compare')).to_list(),
      \ [3,2,1])

      delfunction Compare
    End

    It sorts elements in stream with comparator by Data.Closure
      let by_desc = Closure.from_expr('a:1 > a:2 ? -1 : a:1 ==# a:2 ? 0 : 1')
      Assert Equals(Stream.empty().sorted(by_desc).to_list(), [])
      Assert Equals(Stream.of(2,1,3).sorted(by_desc).to_list(), [3,2,1])
      Assert Equals(Stream.of(2,1,3,2,1).sorted(by_desc).to_list(), [3,2,2,1,1])
      Assert Equals(
      \ Stream.iterate(1, 'v:val + 1').limit(3).sorted(by_desc).to_list(),
      \ [3,2,1])
    End

    It sets SORTED characteristic
      let s = Stream.of(1,2,3).sorted()
      Assert True(s.has_characteristics(Stream.ORDERED()))
      Assert False(s.has_characteristics(Stream.DISTINCT()))
      Assert True(s.has_characteristics(Stream.SORTED()))
      Assert True(s.has_characteristics(Stream.SIZED()))
      Assert True(s.has_characteristics(Stream.IMMUTABLE()))
    End
  End

  Describe .get_comparator()
    It raises exception if comparator is not defined
      try
        call Stream.empty().sorted().get_comparator()
        Assert 0
      catch /vital: Stream: get_comparator(): comparator not found and default argument was not given/
        Assert 1
      endtry
      try
        Assert Equals(Stream.empty().sorted().get_comparator(42), 42)
      catch /vital: Stream: get_comparator(): comparator not found and default argument was not given/
        Assert 0
      endtry
    End

    It raises exception if SORTED flag is not set
      try
        call Stream.empty().get_comparator()
        Assert 0
      catch /vital: Stream: get_comparator(): comparator not found and default argument was not given/
        Assert 1
      endtry
      try
        Assert Equals(Stream.empty().get_comparator(42), 42)
      catch /vital: Stream: get_comparator(): comparator not found and default argument was not given/
        Assert 0
      endtry

      let by_desc = 'v:val[0] > v:val[1] ? -1 : v:val[0] ==# v:val[1] ? 0 : 1'

      " map() clears SORTED flag
      Assert Equals(Stream.of(1,2).sorted(by_desc).map('v:val').get_comparator('NONE'), 'NONE')

      " flatmap() clears SORTED flag
      Assert Equals(Stream.of(1,2).sorted(by_desc).flatmap('[v:val]').get_comparator('NONE'), 'NONE')

      " concat() clears SORTED flag
      Assert Equals(Stream.of(1,2).sorted(by_desc).concat(Stream.of(3,4)).get_comparator('NONE'), 'NONE')
      Assert Equals(Stream.of(1,2).concat(Stream.of(3,4).sorted(by_desc)).get_comparator('NONE'), 'NONE')

      " zip() clears SORTED flag
      Assert Equals(Stream.of(1,2).sorted(by_desc).zip(Stream.of(3,4)).get_comparator('NONE'), 'NONE')
      Assert Equals(Stream.of(1,2).zip(Stream.of(3,4).sorted(by_desc)).get_comparator('NONE'), 'NONE')
    End

    It finds a comparator from a upstream
      let by_desc = 'v:val[0] > v:val[1] ? -1 : v:val[0] ==# v:val[1] ? 0 : 1'
      Assert Equals(Stream.empty().sorted(by_desc).get_comparator(), by_desc)
      Assert Equals(Stream.of(1,2).sorted(by_desc).get_comparator(), by_desc)

      Assert Equals(Stream.of(1,2).sorted(by_desc).limit(1).get_comparator(), by_desc)
      Assert Equals(Stream.of(1,2).sorted(by_desc).skip(1).get_comparator(), by_desc)
    End
  End

  Describe .reduce()
    It raises exception for empty stream
      try
        call Stream.empty().reduce('v:val')
        Assert 0
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 1
      endtry
    End

    It reduces stream
      Assert Equals(Stream.empty().reduce('v:val', 42), 42)
      Assert Equals(Stream.of(1,2,3,4,5).reduce('v:val[0] + v:val[1]'), 15)
      Assert Equals(Stream.of(1,2,3,4,5).reduce('v:val[0] + v:val[1]', 0), 15)
    End

    It reduces stream by funcref
      function! Plus(a, b) abort
        return a:a + a:b
      endfunction

      Assert Equals(Stream.empty().reduce(function('Id'), 42), 42)
      Assert Equals(Stream.of(1,2,3,4,5).reduce(function('Plus')), 15)
      Assert Equals(Stream.of(1,2,3,4,5).reduce(function('Plus'), 0), 15)

      delfunction Plus
    End

    It reduces stream by Data.Closure
      Assert Equals(Stream.empty().reduce(Closure.from_expr('a:1'), 42), 42)
      Assert Equals(Stream.of(1,2,3,4,5).reduce(Closure.from_operator('+')), 15)
      Assert Equals(Stream.of(1,2,3,4,5).reduce(Closure.from_operator('+'), 0), 15)
    End
  End

  Describe .max()
    It raises exception for empty stream
      try
        call Stream.empty().max()
        Assert 0
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 1
      endtry
      try
        Assert Equals(Stream.empty().max(42), 42)
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 0
      endtry
    End

    It returns max value in stream
      Assert Equals(Stream.of(1,2,3,4,5).max(), 5)
    End
  End

  Describe .max_by()
    It raises exception for empty stream
      try
        call Stream.empty().max_by('v:val')
        Assert 0
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 1
      endtry
      try
        Assert Equals(Stream.empty().max_by('v:val', 42), 42)
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 0
      endtry
    End

    It returns max value in stream
      Assert Equals(Stream.of('aaa', 'bb', '').max_by('len(v:val)'), 'aaa')
    End

    It returns max value in stream by funcref
      function! Len(v) abort
        return len(a:v)
      endfunction

      Assert Equals(Stream.of('aaa', 'bb', '').max_by(function('Len')), 'aaa')

      delfunction Len
    End

    It returns max value in stream by Data.Closure
      Assert Equals(Stream.of('aaa', 'bb', '').max_by(Closure.from_funcname('len')), 'aaa')
    End
  End

  Describe .min()
    It raises exception for empty stream
      try
        call Stream.empty().min()
        Assert 0
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 1
      endtry
      try
        Assert Equals(Stream.empty().min(42), 42)
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 0
      endtry
    End

    It returns min value in stream
      Assert Equals(Stream.of(1,2,3,4,5).min(), 1)
    End
  End

  Describe .min_by()
    It raises exception for empty stream
      try
        call Stream.empty().min_by('v:val')
        Assert 0
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 1
      endtry
      try
        Assert Equals(Stream.empty().min_by('v:val', 42), 42)
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 0
      endtry
    End

    It returns min value in stream
      Assert Equals(Stream.of('aaa', 'bb', '').min_by('len(v:val)'), '')
    End

    It returns min value in stream by funcref
      function! Len(v) abort
        return len(a:v)
      endfunction

      Assert Equals(Stream.of('aaa', 'bb', '').min_by(function('Len')), '')

      delfunction Len
    End

    It returns min value in stream by Data.Closure
      Assert Equals(Stream.of('aaa', 'bb', '').min_by(Closure.from_funcname('len')), '')
    End
  End

  Describe .first()
    It raises exception for empty stream
      try
        call Stream.empty().first()
        Assert 0
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 1
      endtry
      try
        Assert Equals(Stream.empty().first(42), 42)
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 0
      endtry
    End

    It returns the first element in stream
      Assert Equals(Stream.of('aaa', 'bb', '').first(), 'aaa')
      Assert Equals(Stream.iterate(1, 'v:val + 1').filter('v:val % 2 == 0').limit(1).first(), 2)
    End
  End

  Describe .last()
    It raises exception for empty stream
      try
        call Stream.empty().last()
        Assert 0
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 1
      endtry
      try
        Assert Equals(Stream.empty().last(42), 42)
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 0
      endtry
    End

    It returns the last element in stream
      Assert Equals(Stream.of('aaa', 'bb', '').last(), '')
      Assert Equals(Stream.iterate(1, 'v:val + 1').filter('v:val % 2 == 0').take_while('v:val <= 10').last(), 10)
    End
  End

  Describe .find()
    It raises exception for empty stream
      try
        call Stream.empty().find('v:val')
        Assert 0
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 1
      endtry
      try
        Assert Equals(Stream.empty().find('v:val', 42), 42)
      catch /vital: Stream: \w\+(): stream is empty and default value was not given/
        Assert 0
      endtry
    End

    It returns the first element matching with given predicate function in stream
      Assert Equals(Stream.iterate(1, 'v:val + 1').find('v:val % 2 == 0'), 2)
    End

    It returns the first element matching with given predicate function in stream by funcref
      Assert Equals(Stream.iterate(1, function('Succ')).find(function('IsEven')), 2)
    End

    It returns the first element matching with given predicate function in stream by Data.Closure
      Assert Equals(Stream.iterate(1, Closure.from_expr('a:1 + 1')).find(Closure.from_expr('a:1 % 2 == 0')), 2)
    End
  End

  Describe .any()
    It returns boolean value if any elements are matched in stream
      Assert False(Stream.empty().any('v:val'))
      Assert True(Stream.of(1,2,3).any('v:val > 2'))
      Assert False(Stream.of(1,2,3).any('v:val > 3'))
    End

    It returns boolean value if any elements are matched in stream by funcref
      function! GreaterThan2(n) abort
        return a:n > 2
      endfunction
      function! GreaterThan3(n) abort
        return a:n > 3
      endfunction

      Assert False(Stream.empty().any(function('Id')))
      Assert True(Stream.of(1,2,3).any(function('GreaterThan2')))
      Assert False(Stream.of(1,2,3).any(function('GreaterThan3')))

      delfunction GreaterThan2
      delfunction GreaterThan3
    End

    It returns boolean value if any elements are matched in stream by Data.Closure
      Assert False(Stream.empty().any(Closure.from_expr('a:1')))
      Assert True(Stream.of(1,2,3).any(Closure.from_expr('a:1 > 2')))
      Assert False(Stream.of(1,2,3).any(Closure.from_expr('a:1 > 3')))
    End
  End

  Describe .all()
    It returns boolean value if all elements are matched in stream
      Assert True(Stream.empty().all('v:val'))
      Assert True(Stream.of(1,2,3).all('v:val > 0'))
      Assert False(Stream.of(1,2,3).all('v:val > 1'))
    End

    It returns boolean value if all elements are matched in stream by funcref
      function! GreaterThan0(n) abort
        return a:n > 0
      endfunction
      function! GreaterThan1(n) abort
        return a:n > 1
      endfunction

      Assert True(Stream.empty().all(function('Id')))
      Assert True(Stream.of(1,2,3).all(function('GreaterThan0')))
      Assert False(Stream.of(1,2,3).all(function('GreaterThan1')))

      delfunction GreaterThan0
      delfunction GreaterThan1
    End

    It returns boolean value if all elements are matched in stream by Data.Closure
      Assert True(Stream.empty().all(Closure.from_expr('a:1')))
      Assert True(Stream.of(1,2,3).all(Closure.from_expr('a:1 > 0')))
      Assert False(Stream.of(1,2,3).all(Closure.from_expr('a:1 > 1')))
    End
  End

  Describe .none()
    It returns boolean value if none elements are matched in stream
      Assert True(Stream.empty().none('v:val'))
      Assert True(Stream.of(1,2,3).none('v:val > 3'))
      Assert False(Stream.of(1,2,3).none('v:val > 2'))
    End

    It returns boolean value if none elements are matched in stream by funcref
      function! GreaterThan3(n) abort
        return a:n > 3
      endfunction
      function! GreaterThan2(n) abort
        return a:n > 2
      endfunction

      Assert True(Stream.empty().none(function('Id')))
      Assert True(Stream.of(1,2,3).none(function('GreaterThan3')))
      Assert False(Stream.of(1,2,3).none(function('GreaterThan2')))

      delfunction GreaterThan3
      delfunction GreaterThan2
    End

    It returns boolean value if none elements are matched in stream by Data.Closure
      Assert True(Stream.empty().none(Closure.from_expr('a:1')))
      Assert True(Stream.of(1,2,3).none(Closure.from_expr('a:1 > 3')))
      Assert False(Stream.of(1,2,3).none(Closure.from_expr('a:1 > 2')))
    End
  End

  Describe .string_join()
    It joins elements in stream
      Assert Equals(Stream.empty().string_join(), '')
      Assert Equals(Stream.of(1).string_join(), '1')
      Assert Equals(Stream.of(1,2,3).string_join(), '1 2 3')
      Assert Equals(Stream.of(1,2,3).string_join(','), '1,2,3')
      Assert Equals(Stream.of('foo').string_join(), 'foo')
      Assert Equals(Stream.of('foo', 'bar', 'baz').string_join(), 'foo bar baz')
      Assert Equals(Stream.of('foo', 'bar', 'baz').string_join(','), 'foo,bar,baz')
    End
  End

  Describe .group_by()
    It groups stream
      Assert Equals(Stream.empty().group_by('v:val'), {})
      Assert Equals(Stream.of(1).group_by('v:val'), {'1': [1]})
      Assert Equals(Stream.of(1,2,3).group_by('v:val'), {'1': [1], '2': [2], '3': [3]})
      Assert Equals(Stream.of(1,2,3,2,1).group_by('v:val'), {'1': [1,1], '2': [2,2], '3': [3]})
      Assert Equals(Stream.of('foo', 'bar', 'baz').group_by('v:val'), {'foo': ['foo'], 'bar': ['bar'], 'baz': ['baz']})
      Assert Equals(Stream.of('a', 'bb', 'ccc').group_by('len(v:val)'), {'1': ['a'], '2': ['bb'], '3': ['ccc']})
      Assert Equals(Stream.of('a', 'bb', 'ccc', 'ddd').group_by('len(v:val)'), {'1': ['a'], '2': ['bb'], '3': ['ccc', 'ddd']})
    End

    It groups stream by funcref
      function! Len(v) abort
        return len(a:v)
      endfunction

      Assert Equals(Stream.empty().group_by(function('Id')), {})
      Assert Equals(Stream.of(1).group_by(function('Id')), {'1': [1]})
      Assert Equals(Stream.of(1,2,3).group_by(function('Id')), {'1': [1], '2': [2], '3': [3]})
      Assert Equals(Stream.of(1,2,3,2,1).group_by(function('Id')), {'1': [1,1], '2': [2,2], '3': [3]})
      Assert Equals(Stream.of('foo', 'bar', 'baz').group_by(function('Id')), {'foo': ['foo'], 'bar': ['bar'], 'baz': ['baz']})
      Assert Equals(Stream.of('a', 'bb', 'ccc').group_by(function('Len')), {'1': ['a'], '2': ['bb'], '3': ['ccc']})
      Assert Equals(Stream.of('a', 'bb', 'ccc', 'ddd').group_by(function('Len')), {'1': ['a'], '2': ['bb'], '3': ['ccc', 'ddd']})

      delfunction Len
    End

    It groups stream by Data.Closure
      let id = Closure.from_expr('a:1')
      let len = Closure.from_funcname('len')

      Assert Equals(Stream.empty().group_by(id), {})
      Assert Equals(Stream.of(1).group_by(id), {'1': [1]})
      Assert Equals(Stream.of(1,2,3).group_by(id), {'1': [1], '2': [2], '3': [3]})
      Assert Equals(Stream.of(1,2,3,2,1).group_by(id), {'1': [1,1], '2': [2,2], '3': [3]})
      Assert Equals(Stream.of('foo', 'bar', 'baz').group_by(id), {'foo': ['foo'], 'bar': ['bar'], 'baz': ['baz']})
      Assert Equals(Stream.of('a', 'bb', 'ccc').group_by(len), {'1': ['a'], '2': ['bb'], '3': ['ccc']})
      Assert Equals(Stream.of('a', 'bb', 'ccc', 'ddd').group_by(len), {'1': ['a'], '2': ['bb'], '3': ['ccc', 'ddd']})
    End
  End

  Describe .to_dict()
    It converts elements to Dictionary in stream
      Assert Equals(Stream.empty().to_dict('v:val', 'v:val'), {})
      Assert Equals(Stream.of(1).to_dict('v:val', 'v:val'), {'1': 1})
      Assert Equals(Stream.of(1,2,3).to_dict('v:val', 'v:val'), {'1': 1, '2': 2, '3': 3})
      Assert Equals(Stream.of('foo', 'bar', 'baz').to_dict('v:val', 'v:val'), {'foo': 'foo', 'bar': 'bar', 'baz': 'baz'})
      Assert Equals(Stream.of('a', 'bb', 'ccc').to_dict('len(v:val)', 'v:val'), {'1': 'a', '2': 'bb', '3': 'ccc'})
    End

    It converts elements to Dictionary in stream with merge function
      try
        call Stream.of(1,2,3,2,1).to_dict('v:val', 'v:val')
        Assert 0
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '2')/
        Assert 1
      endtry
      try
        Assert Equals(
          \Stream.of(1,2,3,2,1)
            \.to_dict('v:val', '[v:val]', 'v:val[0] + v:val[1]'),
          \{'1': [1,1], '2': [2,2], '3': [3]})
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '2')/
        Assert 0
      endtry

      try
        call Stream.of('a', 'bb', 'ccc', 'ddd').to_dict('len(v:val)', 'v:val')
        Assert 0
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '3')/
        Assert 1
      endtry
      try
        Assert Equals(
          \Stream.of('a', 'bb', 'ccc', 'ddd')
            \.to_dict('len(v:val)', '[v:val]'),
          \{'1': ['a'], '2': ['bb'], '3': ['ccc', 'ddd']})
        Assert 0
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '3')/
        Assert 1
      endtry
    End

    It converts elements to Dictionary in stream by funcref
      function! Len(v) abort
        return len(a:v)
      endfunction

      Assert Equals(Stream.empty().to_dict(function('Id'), function('Id')), {})
      Assert Equals(Stream.of(1).to_dict(function('Id'), function('Id')), {'1': 1})
      Assert Equals(Stream.of(1,2,3).to_dict(function('Id'), function('Id')), {'1': 1, '2': 2, '3': 3})
      Assert Equals(Stream.of('foo', 'bar', 'baz').to_dict(function('Id'), function('Id')), {'foo': 'foo', 'bar': 'bar', 'baz': 'baz'})
      Assert Equals(Stream.of('a', 'bb', 'ccc').to_dict(function('Len'), function('Id')), {'1': 'a', '2': 'bb', '3': 'ccc'})

      delfunction Len
    End

    It converts elements to Dictionary in stream with merge function by funcref
      function! Len(v) abort
        return len(a:v)
      endfunction
      function! List(v) abort
        return [a:v]
      endfunction
      function! Plus(a, b) abort
        return a:a + a:b
      endfunction

      try
        call Stream.of(1,2,3,2,1).to_dict(function('Id'), function('Id'))
        Assert 0
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '2')/
        Assert 1
      endtry
      try
        Assert Equals(
          \Stream.of(1,2,3,2,1)
            \.to_dict(function('Id'), function('List'), function('Plus')),
          \{'1': [1,1], '2': [2,2], '3': [3]})
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '2')/
        Assert 0
      endtry

      try
        call Stream.of('a', 'bb', 'ccc', 'ddd').to_dict(function('Len'), function('Id'))
        Assert 0
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '3')/
        Assert 1
      endtry
      try
        Assert Equals(
          \Stream.of('a', 'bb', 'ccc', 'ddd')
            \.to_dict(function('Len'), function('List')),
          \{'1': ['a'], '2': ['bb'], '3': ['ccc', 'ddd']})
        Assert 0
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '3')/
        Assert 1
      endtry

      delfunction Len
      delfunction List
      delfunction Plus
    End

    It converts elements to Dictionary in stream by Data.Closure
      let id = Closure.from_expr('a:1')
      let len = Closure.from_funcname('len')

      Assert Equals(Stream.empty().to_dict(id, id), {})
      Assert Equals(Stream.of(1).to_dict(id, id), {'1': 1})
      Assert Equals(Stream.of(1,2,3).to_dict(id, id), {'1': 1, '2': 2, '3': 3})
      Assert Equals(Stream.of('foo', 'bar', 'baz').to_dict(id, id), {'foo': 'foo', 'bar': 'bar', 'baz': 'baz'})
      Assert Equals(Stream.of('a', 'bb', 'ccc').to_dict(len, id), {'1': 'a', '2': 'bb', '3': 'ccc'})
    End

    It converts elements to Dictionary in stream with merge function by Data.Closure
      let id = Closure.from_expr('a:1')
      let len = Closure.from_funcname('len')
      let list = Closure.from_expr('[a:1]')
      let plus = Closure.from_operator('+')

      try
        call Stream.of(1,2,3,2,1).to_dict(id, id)
        Assert 0
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '2')/
        Assert 1
      endtry
      try
        Assert Equals(
          \Stream.of(1,2,3,2,1)
            \.to_dict(id, list, plus),
          \{'1': [1,1], '2': [2,2], '3': [3]})
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '2')/
        Assert 0
      endtry

      try
        call Stream.of('a', 'bb', 'ccc', 'ddd').to_dict(len, id)
        Assert 0
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '3')/
        Assert 1
      endtry
      try
        Assert Equals(
          \Stream.of('a', 'bb', 'ccc', 'ddd')
            \.to_dict(len, list),
          \{'1': ['a'], '2': ['bb'], '3': ['ccc', 'ddd']})
        Assert 0
      catch /vital: Stream: to_dict(): duplicated elements exist in stream (key: '3')/
        Assert 1
      endtry
    End
  End

  Describe .sum()
    It sums elements in stream
      Assert Equals(Stream.empty().sum(), 0)
      Assert Equals(Stream.of(1,2,3).sum(), 6)
    End
  End

  Describe .average()
    It averages elements in stream
      try
        call Stream.empty().average()
        Assert 0
      catch /vital: Stream: average(): empty stream cannot be average()d/
        Assert 1
      endtry
      Assert Equals(Stream.of(2).average(), 2)
      Assert Equals(Stream.of(1,2,3).average(), 2)
      Assert Equals(Stream.of(-5,0,5).average(), 0)
    End
  End

  Describe .count()
    It counts elements in stream
      Assert Equals(Stream.empty().count(), 0)
      Assert Equals(Stream.of(1,2,3).count(), 3)
      Assert Equals(Stream.iterate(1, 'v:val + 1').count(), 1/0)
    End

    It counts elements by predicate function in stream
      Assert Equals(Stream.empty().count('v:val'), 0)
      Assert Equals(Stream.of(1,2,3).count('v:val % 2 == 0'), 1)
      Assert Equals(Stream.iterate(1, 'v:val + 1').count('v:val % 2 == 0'), 1/0)
    End

    It counts elements by predicate function in stream by funcref
      Assert Equals(Stream.empty().count(function('Id')), 0)
      Assert Equals(Stream.of(1,2,3).count(function('IsEven')), 1)
      Assert Equals(Stream.iterate(1, 'v:val + 1').count(function('IsEven')), 1/0)
    End

    It counts elements by predicate function in stream by Data.Closure
      Assert Equals(Stream.empty().count(function('Id')), 0)
      Assert Equals(Stream.of(1,2,3).count(Closure.from_expr('a:1 % 2 == 0')), 1)
      Assert Equals(Stream.iterate(1, 'v:val + 1').count(Closure.from_expr('a:1 % 2 == 0')), 1/0)
    End
  End

  Describe .to_list()
    It converts stream to a List
      Assert Equals(Stream.of(1,2,3).to_list(), [1,2,3])
    End

    It must not reuse stream
      try
        let s = Stream.of(1,2,3,4,5)
        call s.to_list()
        call s.to_list()
        Assert 0
      catch
        Assert 1
      endtry
    End
  End

  Describe .generator()
    It supports interface of generator function like Java's Spliterator
      let generator = {}
      function! generator.yield(times, NONE) abort
        if a:times >= 3
          return a:NONE
        endif
        return a:times
      endfunction

      Assert Equals(Stream.generator(generator).to_list(), [0,1,2])
    End

    It supports interface of infinite generator function like Java's Spliterator
      let generator = {}
      function! generator.yield(times, NONE) abort
        return a:times
      endfunction

      Assert Equals(Stream.generator(generator).limit(5).to_list(), [0,1,2,3,4])
    End
  End
End

" vim: ft=vim
