scriptencoding utf-8

let s:V = vital#of('vital')
let s:Prelude = s:V.import('Prelude')
let s:Path = s:V.import('System.Filepath')

Describe System.Process
  Before
    let Process = s:V.import('System.Process')
  End

  Describe .iconv({expr}, {from}, {to})
    It does nothing when {from} or {to} is an empty string or {from} is equal to {to}
      let expr = "aあiいuうeえoお"
      Assert Same(Process.iconv(expr, '', ''), expr)
      Assert Same(Process.iconv(expr, 'utf-8', ''), expr)
      Assert Same(Process.iconv(expr, '', 'utf-8'), expr)
      Assert Same(Process.iconv(expr, 'utf-8', 'utf-8'), expr)
    End

    It return {expr} when the conversion completely fails
      " XXX : Give an example code to force iconv to fail completely
      Skip Need knowledge about how to force iconv to fail completely
    End

    It return string with '?' for unconvertable characters
      let expr = "aあiいuうeえoお"
      if &encoding ==# 'eucjp'
        Assert Equal(Process.iconv(expr, 'sjis', 'latin1'), 'a??i??u??e??o??')
      else
        Assert Equal(Process.iconv(expr, 'eucjp', 'latin1'), 'a??i??u??e??o??')
      endif
    End

    It return string with {to} encoding
      let expr = "aあiいuうeえoお"
      let sjis = readfile(s:Path.realpath(
            \ 'test/_testdata/System/Process/sjis.txt'
            \))[0]
      Assert Equal(Process.iconv(expr, &encoding, 'sjis'), sjis)
    End
  End

  Describe .repair_posix_text({text})
    It append a trailing "\n" if no trailing newline (\r?\n) is found
      let text = "abcdefg\nhijklmn\nopqrstu"
      Assert Equals(Process.repair_posix_text(text), "abcdefg\nhijklmn\nopqrstu\n")
    End

    It does nothing if a trailing newline is found
      let text = "abcdefg\nhijklmn\nopqrstu\n"
      Assert Same(Process.repair_posix_text(text), text)
      let text = "abcdefg\nhijklmn\nopqrstu\r\n"
      Assert Same(Process.repair_posix_text(text), text)
      let text = "abcdefg\nhijklmn\nopqrstu\r\n\n"
      Assert Same(Process.repair_posix_text(text), text)
      let text = "abcdefg\nhijklmn\nopqrstu\r\n\r\n"
      Assert Same(Process.repair_posix_text(text), text)
    End
  End

  Describe .join_posix_lines({lines}[, {newline}])
    It return a POSIX text
      let exp = "AAAAA\nBBBBB\nCCCCC\n"
      let lines = [
            \ 'AAAAA',
            \ 'BBBBB',
            \ 'CCCCC',
            \]
      Assert Equals(Process.join_posix_lines(lines), exp)

      let exp = "\n\nAAAAA\nBBBBB\nCCCCC\n\n\n"
      let lines = [
            \ '',
            \ '',
            \ 'AAAAA',
            \ 'BBBBB',
            \ 'CCCCC',
            \ '',
            \ '',
            \]
      Assert Equals(Process.join_posix_lines(lines), exp)
    End
  End

  Describe .split_posix_text({text}[, {newline}])
    It split a POSIX text file into lines
      " NOTE:
      " POSIX text file is a corretion of lines
      " POSIX line is a character correction ends with a newline
      let exp = [
            \ 'AAAAA',
            \ 'BBBBB',
            \ 'CCCCC',
            \]
      let text = "AAAAA\nBBBBB\nCCCCC\n"
      Assert Equals(Process.split_posix_text(text), exp)

      let text = "AAAAA\r\nBBBBB\r\nCCCCC\r\n"
      Assert Equals(Process.split_posix_text(text), exp)
    End

    It split a POSIX text file into lines, even for empty lines
      let exp = [
            \ '',
            \ '',
            \ 'AAAAA',
            \ 'BBBBB',
            \ 'CCCCC',
            \ '',
            \ '',
            \]
      let text = "\n\nAAAAA\nBBBBB\nCCCCC\n\n\n"
      Assert Equals(Process.split_posix_text(text), exp)

      let text = "\r\n\r\nAAAAA\r\nBBBBB\r\nCCCCC\r\n\r\n\r\n"
      Assert Equals(Process.split_posix_text(text), exp)
    End

    It split an invalid POSIX text file into lines
      let exp = [
            \ 'AAAAA',
            \ 'BBBBB',
            \ 'CCCCC',
            \]
      " NOTE:
      " The following text is invalid while no trailing newline exists
      let text = "AAAAA\nBBBBB\nCCCCC"
      Assert Equals(Process.split_posix_text(text), exp)

      " The following text is invalid while no trailing newline exists
      let text = "AAAAA\r\nBBBBB\r\nCCCCC"
      Assert Equals(Process.split_posix_text(text), exp)
    End
  End

  Describe .execute({args}, {options})
    " NOTE:
    " Tests for actual process call are in System/Process/XXXXX.vimspec
    It uses a String item in {options.clients} as a process client
      let args = s:Prelude.is_windows()
            \ ? ['cmd', '/C', 'exit 0']
            \ : ['true']
      let result = Process.execute(args, {
            \ 'clients': ['System.Process.System'],
            \})
      Assert Equals(result.success, 1)
      Assert Equals(result.output, '')
    End

    It uses a Dictionary item in {options.clients} as a process client
      let Mock = s:V.import('System.Process.Mock')
      let result = Process.execute(['foo', 'bar'], {
            \ 'clients': [Mock],
            \})
      Assert Equals(result.success, 1)
      Assert Equals(result.output, 'Output of System.Process.Mock')
    End
  End
End
