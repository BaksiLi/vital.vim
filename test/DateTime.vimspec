Describe DateTime
  Before all
    let DT = vital#of('vital').import('DateTime')
  End

  Context .from_unix_time()
    It makes a DateTime object from unix time
      let dt = DT.from_unix_time(1325441045, 9)
      Assert Equals(dt.year(), 2012)
      Assert Equals(dt.month(), 1)
      Assert Equals(dt.day(), 2)
      Assert Equals(dt.hour(), 3)
      Assert Equals(dt.minute(), 4)
      Assert Equals(dt.second(), 5)
    End
  End

  Describe .from_date()
    It makes a DateTime object from date info
      let dt = DT.from_date(2012, 1, 2, 3, 4, 5)
      Assert Equals(dt.year(), 2012)
      Assert Equals(dt.month(), 1)
      Assert Equals(dt.day(), 2)
      Assert Equals(dt.hour(), 3)
      Assert Equals(dt.minute(), 4)
      Assert Equals(dt.second(), 5)
    End
  End

  Describe .from_format()
    It makes a DateTime object from formatted string
      let dt = DT.from_format('2012-1-02T03:04:05Z', '%Y-%m-%dT%H:%M:%SZ%z')
      Assert Equals(dt.year(), 2012)
      Assert Equals(dt.month(), 1)
      Assert Equals(dt.day(), 2)
      Assert Equals(dt.hour(), 3)
      Assert Equals(dt.minute(), 4)
      Assert Equals(dt.second(), 5)
      Assert Equals(dt.timezone().offset(), 0)
    End
    It can treat the some format specifier
      let dt = DT.from_format('02 Jan 2012 03:04:05 +0900', '%d %b %Y%n%H:%M:%S%n%z', 'C')
      Assert Equals(dt.year(), 2012)
      Assert Equals(dt.month(), 1)
      Assert Equals(dt.day(), 2)
      Assert Equals(dt.hour(), 3)
      Assert Equals(dt.minute(), 4)
      Assert Equals(dt.second(), 5)
      Assert Equals(dt.timezone().hours(), 9)
    End
    It can skip any text by %*
      let dt = DT.from_format('2011-01-03T10:16:46.297581Z', '%Y-%m-%dT%H:%M:%S%*Z%z', 'C')
      Assert Equals(dt.year(), 2011)
      Assert Equals(dt.month(), 1)
      Assert Equals(dt.day(), 3)
      Assert Equals(dt.hour(), 10)
      Assert Equals(dt.minute(), 16)
      Assert Equals(dt.second(), 46)
      Assert Equals(dt.timezone().hours(), 0)
    End
    It throws an exception with invalid format
      Throws /^vital: DateTime:/ DT.from_format('Invalid Date', '%Y-%m-%dT%H:%M:%S%*Z%z')
    End
  End

  Describe .from_julian_day()
    It makes a DateTime object from string
      let dt = DT.from_julian_day(2455928.627836, 0)
      Assert Equals(dt.year(), 2012)
      Assert Equals(dt.month(), 1)
      Assert Equals(dt.day(), 2)
      Assert Equals(dt.hour(), 3)
      Assert Equals(dt.minute(), 4)
      Assert Equals(dt.second(), 5)
    End
  End

  Describe .timezone()
    It makes a TimeZone object
      let tz = DT.timezone()
      Assert Equals(tz.hours(), 9)
    End
    It makes a TimeZone object from time string
      let tz = DT.timezone('+0900')
      Assert Equals(tz.hours(), 9)
    End
    It makes a TimeZone object from hour
      let tz = DT.timezone(9)
      Assert Equals(tz.hours(), 9)
    End
    It just returns a TimeZone object that was supplied from argument
      let tz = DT.timezone(9)
      let returned = DT.timezone(tz)
      Assert Same(returned, tz)
    End
    It throws an exception with invalid argument
      Throws /^vital: DateTime:/ DT.timezone({})
      Throws /^vital: DateTime:/ DT.timezone('abc')
    End
  End

  Describe .delta()
    It makes TimeDelta object from days and seconds
      let d = DT.delta(10, 10000)
      Assert Equals(d.days(), 10)
      Assert Equals(d.hours(), 2)
      Assert Equals(d.minutes(), 46)
      Assert Equals(d.seconds(), 40)
      Assert Equals(d.total_seconds(), 874000)
    End
    It makes TimeDelta object from values and units
      let d = DT.delta(10, 'days', 2, 'hours', 46, 'minutes', 40, 'seconds')
      Assert Equals(d.days(), 10)
      Assert Equals(d.hours(), 2)
      Assert Equals(d.minutes(), 46)
      Assert Equals(d.seconds(), 40)
      Assert Equals(d.total_seconds(), 874000)
    End
  End

  Describe .compare()
    It returns -1 when left one is later more than right one
      let left =  DT.from_format('2014-12-01 12:00:00 +0000', '%c')
      let right = DT.from_format('2014-12-02 12:00:00 +0000', '%c')
      Assert Equals(DT.compare(left, right), -1)

      let left =  DT.from_format('2014-12-02 00:00:00 +0900', '%c')
      let right = DT.from_format('2014-12-01 12:00:00 -0800', '%c')
      Assert Equals(DT.compare(left, right), -1)
    End
    It returns 0 when left one and right one is same time
      let left =  DT.from_format('2014-12-01 12:00:00 +0000', '%c')
      let right = DT.from_format('2014-12-01 12:00:00 +0000', '%c')
      Assert Equals(DT.compare(left, right), 0)

      let left =  DT.from_format('2014-12-02 12:00:00 +0900', '%c')
      let right = DT.from_format('2014-12-01 19:00:00 -0800', '%c')
      Assert Equals(DT.compare(left, right), 0)
    End
    It returns 1 when left one is precedes more than right one
      let left =  DT.from_format('2014-12-02 12:00:00 +0000', '%c')
      let right = DT.from_format('2014-12-01 12:00:00 +0000', '%c')
      Assert Equals(DT.compare(left, right), 1)

      let left =  DT.from_format('2014-12-01 12:00:00 -0800', '%c')
      let right = DT.from_format('2014-12-02 00:00:00 +0900', '%c')
      Assert Equals(DT.compare(left, right), 1)
    End
  End

  Describe .month_names()
    Context {longname} = 0
      It returns the list of name of months
        let names = DT.month_names(0, 'C')
        Assert Equals(names,
        \ ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
        \  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'])
      End
    End
    Context {longname} is 1
      It returns the list of long name of months
        let names = DT.month_names(1, 'C')
        Assert Equals(names,
        \ ['January', 'February', 'March', 'April', 'May', 'June',
        \  'July', 'August', 'September', 'October', 'November', 'December'])
      End
    End
  End

  Describe .weekday_names()
    Context {longname} = 0
      It returns the list of name of weekdays
        let names = DT.weekday_names(0, 'C')
        Assert Equals(names,
        \ ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'])
      End
    End
    Context {longname} is 1
      It returns the list of long name of weekdays
        let names = DT.weekday_names(1, 'C')
        Assert Equals(names,
        \ ['Sunday', 'Monday', 'Tuesday',
        \   'Wednesday', 'Thursday', 'Friday', 'Saturday'])
      End
    End
  End

  Describe .am_pm_names()
    Context {lowercase} = 0
      It returns the list of am/pm names in uppercase
        let names = DT.am_pm_names(0, 'C')
        Assert Equals(names, ['AM', 'PM'])
      End
    End
    Context {lowercase} is 1
      It returns the list of am/pm names in lowercase
        let names = DT.am_pm_names(1, 'C')
        Assert Equals(names, ['am', 'pm'])
      End
    End
  End

  Describe .is_leap_year()
    It judges whether a year is a leap year
      Assert Truthy(DT.is_leap_year(1996))
      Assert Truthy(DT.is_leap_year(2000))
      Assert Truthy(DT.is_leap_year(2004))
      Assert Falsy(DT.is_leap_year(1900))
      Assert Falsy(DT.is_leap_year(2006))
      Assert Falsy(DT.is_leap_year(2100))
    End
  End

  Describe DateTime object
    " TODO
  End

  Describe TimeZone object
    " TODO
  End

  Describe TimeDelta object
    Before each
      let delta = DT.delta(63, 'days', 3, 'hours', 4, 'minutes', 5, 'seconds')
    End

    Describe .seconds()
      It returns seconds component
        Assert Equals(delta.seconds(), 5)
      End
    End

    Describe .minutes()
      It returns minutes component
        Assert Equals(delta.minutes(), 4)
      End
    End

    Describe .hours()
      It returns hours component
        Assert Equals(delta.hours(), 3)
      End
    End

    Describe .days()
      It returns days component
        Assert Equals(delta.days(), 63)
      End
    End

    Describe .total_seconds()
      It returns the total seconds of the delta
        Assert Equals(delta.total_seconds(), 5454245)
      End
    End

    Describe .sign()
      It returns the sign of the delta
        Assert Equals(delta.sign(), 1)
      End
    End

    Describe .negate()
      It returns new negated TimeDelta object
        let delta = DT.delta(1, 100)
        let result = delta.negate()
        Assert Truthy(result.is(DT.delta(-1, -100)))
        Assert Truthy(result.negate().is(delta))
      End
    End

    Describe .duration()
      It returns new TimeDelta object that is absolute value
        let delta = DT.delta(-1, -100)
        let result = delta.duration()
        Assert Truthy(result.is(DT.delta(1, 100)))
        Assert Truthy(result.duration().is(DT.delta(1, 100)))
      End
    End

    Describe .is()
      It returns true if two TimeDeltas are same
        let delta1 = DT.delta(0, 43200)
        let delta2 = DT.delta(1, -43200)
        Assert Truthy(delta1.is(delta2))
      End
      It returns false if two TimeDeltas are not same
        let delta1 = DT.delta(0, 43200)
        let delta2 = DT.delta(0, -43200)
        Assert Falsy(delta1.is(delta2))
      End
    End

    Describe .add()
      It returns new TimeDelta object which added this and other
        let delta1 = DT.delta(1, 100)
        let delta2 = DT.delta(2, 50)
        let result = delta1.add(delta2)
        Assert Truthy(result.is(DT.delta(3, 150)))
      End
    End

    Describe .subtract()
      It returns new TimeDelta object which subtracted this and other
        let delta1 = DT.delta(1, 100)
        let delta2 = DT.delta(2, 150)
        let result = delta1.subtract(delta2)
        Assert Truthy(result.is(DT.delta(-1, -50)))
      End
    End

    Describe .about()
      It returns a string that about this delta
        Assert Equals(delta.about(), '2 months later')
        Assert Equals(delta.negate().about(), '2 months ago')
        Assert Equals(DT.delta(740, 0).about(), '2 years later')
        Assert Equals(DT.delta(10, 0).about(), '1 week later')
        Assert Equals(DT.delta(0, 0).about(), 'now')
        Assert Equals(DT.delta(0, -50).about(), '50 seconds ago')
        Assert Equals(DT.delta(0, -500).about(), '8 minutes ago')
        Assert Equals(DT.delta(0, -5000).about(), '1 hour ago')
      End
    End

    Describe .to_string()
      It returns a string representation
        Assert Equals(delta.to_string(), '63days, 03:04:05')
        Assert Equals(delta.negate().to_string(), '-63days, 03:04:05')
        Assert Equals(DT.delta(1, 3600).to_string(), '1day, 01:00:00')
        Assert Equals(DT.delta(0, 3600).to_string(), '01:00:00')
        Assert Equals(DT.delta(0, -3600).to_string(), '-01:00:00')
      End
    End

    Context with strange initialization
      It is normalized correctly (plus)
        let delta = DT.delta(0, (60 * 60 * 24 * 5) + (60 * 60 * 4) + (60 * 3) + 25)
        Assert Equals(delta.days(), 5)
        Assert Equals(delta.hours(), 4)
        Assert Equals(delta.minutes(), 3)
        Assert Equals(delta.seconds(), 25)
        Assert Equals(delta.sign(), 1)
      End
      It is normalized correctly (minus)
        let delta = DT.delta(-10, (60 * 60 * 24 * 5) + (60 * 60 * 4) + (60 * 3) + 25)
        Assert Equals(delta.days(), -4)
        Assert Equals(delta.hours(), -19)
        Assert Equals(delta.minutes(), -56)
        Assert Equals(delta.seconds(), -35)
        Assert Equals(delta.sign(), -1)
      End
      It is normalized correctly (zero)
        let delta = DT.delta(5, 60 * 60 * 24 * -5)
        Assert Equals(delta.days(), 0)
        Assert Equals(delta.hours(), 0)
        Assert Equals(delta.minutes(), 0)
        Assert Equals(delta.seconds(), 0)
        Assert Equals(delta.sign(), 0)
      End
    End
  End
End
